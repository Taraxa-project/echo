import 'package:td_json_client/api/base.dart';

/// Points to a file
abstract class InputFile extends TdObject {
  InputFile({super.extra, super.client_id});
}


/// A file defined by its unique ID 
class InputFileId extends InputFile {
  String get tdType => 'inputFileId';


  /// Unique file identifier
  int32? id;

  InputFileId({
    super.extra,
    super.client_id,
    this.id,
  });

  InputFileId.fromMap(Map<String, dynamic> map) {
    extra = map['@extra'];
    client_id = map['@client_id'];
    id = map['id'];
  }

  Map<String, dynamic> toMap({skipNulls = true}) {
    Map<String, dynamic> map = {
      '@type': tdType,
      '@extra': extra?.toMap(skipNulls: skipNulls),
      '@client_id': client_id?.toMap(skipNulls: skipNulls),
      'id': id?.toMap(skipNulls: skipNulls),
    };
    if (skipNulls) {
      map.removeWhere((key, value) => value == null);
    }
    return map;
  }
}

/// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib.
/// For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
class InputFileRemote extends InputFile {
  String get tdType => 'inputFileRemote';


  /// Remote file identifier
  string? id;

  InputFileRemote({
    super.extra,
    super.client_id,
    this.id,
  });

  InputFileRemote.fromMap(Map<String, dynamic> map) {
    extra = map['@extra'];
    client_id = map['@client_id'];
    id = map['id'];
  }

  Map<String, dynamic> toMap({skipNulls = true}) {
    Map<String, dynamic> map = {
      '@type': tdType,
      '@extra': extra?.toMap(skipNulls: skipNulls),
      '@client_id': client_id?.toMap(skipNulls: skipNulls),
      'id': id?.toMap(skipNulls: skipNulls),
    };
    if (skipNulls) {
      map.removeWhere((key, value) => value == null);
    }
    return map;
  }
}

/// A file defined by a local path 
class InputFileLocal extends InputFile {
  String get tdType => 'inputFileLocal';


  /// Local path to the file
  string? path;

  InputFileLocal({
    super.extra,
    super.client_id,
    this.path,
  });

  InputFileLocal.fromMap(Map<String, dynamic> map) {
    extra = map['@extra'];
    client_id = map['@client_id'];
    path = map['path'];
  }

  Map<String, dynamic> toMap({skipNulls = true}) {
    Map<String, dynamic> map = {
      '@type': tdType,
      '@extra': extra?.toMap(skipNulls: skipNulls),
      '@client_id': client_id?.toMap(skipNulls: skipNulls),
      'path': path?.toMap(skipNulls: skipNulls),
    };
    if (skipNulls) {
      map.removeWhere((key, value) => value == null);
    }
    return map;
  }
}

/// A file generated by the application 
class InputFileGenerated extends InputFile {
  String get tdType => 'inputFileGenerated';


  /// Local path to a file from which the file is generated; may be empty if there is no such file
  string? original_path;

  /// String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
  string? conversion;

  /// Expected size of the generated file, in bytes; 0 if unknown
  int53? expected_size;

  InputFileGenerated({
    super.extra,
    super.client_id,
    this.original_path,
    this.conversion,
    this.expected_size,
  });

  InputFileGenerated.fromMap(Map<String, dynamic> map) {
    extra = map['@extra'];
    client_id = map['@client_id'];
    original_path = map['original_path'];
    conversion = map['conversion'];
    expected_size = map['expected_size'];
  }

  Map<String, dynamic> toMap({skipNulls = true}) {
    Map<String, dynamic> map = {
      '@type': tdType,
      '@extra': extra?.toMap(skipNulls: skipNulls),
      '@client_id': client_id?.toMap(skipNulls: skipNulls),
      'original_path': original_path?.toMap(skipNulls: skipNulls),
      'conversion': conversion?.toMap(skipNulls: skipNulls),
      'expected_size': expected_size?.toMap(skipNulls: skipNulls),
    };
    if (skipNulls) {
      map.removeWhere((key, value) => value == null);
    }
    return map;
  }
}
