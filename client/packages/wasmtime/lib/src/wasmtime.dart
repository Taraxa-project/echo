// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class Wasmtime {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Wasmtime(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Wasmtime.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __len,
  ) {
    return _memmove(
      __dst,
      __src,
      __len,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __b,
    int __c,
    int __len,
  ) {
    return _memset(
      __b,
      __c,
      __len,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcat(
      __s1,
      __s2,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dst,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strcspn(
      __s,
      __charset,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncat(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strpbrk(
      __s,
      __charset,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strspn(
      __s,
      __charset,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strstr(
      __big,
      __little,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
  ) {
    return _strtok(
      __str,
      __sep,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strxfrm(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lasts,
  ) {
    return _strtok_r(
      __str,
      __sep,
      __lasts,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __strerrbuf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __strerrbuf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s1,
  ) {
    return _strdup(
      __s1,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dst,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dst,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strndup(
      __s1,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strnlen(
      __s1,
      __n,
    );
  }

  late final _strnlenPtr = _lookup<
          ffi
          .NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>(
      'strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int memset_s(
    ffi.Pointer<ffi.Void> __s,
    int __smax,
    int __c,
    int __n,
  ) {
    return _memset_s(
      __s,
      __smax,
      __c,
      __n,
    );
  }

  late final _memset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Void>, rsize_t, ffi.Int, rsize_t)>>('memset_s');
  late final _memset_s = _memset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  ffi.Pointer<ffi.Void> memmem(
    ffi.Pointer<ffi.Void> __big,
    int __big_len,
    ffi.Pointer<ffi.Void> __little,
    int __little_len,
  ) {
    return _memmem(
      __big,
      __big_len,
      __little,
      __little_len,
    );
  }

  late final _memmemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmem');
  late final _memmem = _memmemPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern4(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern4,
    int __len,
  ) {
    return _memset_pattern4(
      __b,
      __pattern4,
      __len,
    );
  }

  late final _memset_pattern4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern4');
  late final _memset_pattern4 = _memset_pattern4Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern8(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern8,
    int __len,
  ) {
    return _memset_pattern8(
      __b,
      __pattern8,
      __len,
    );
  }

  late final _memset_pattern8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern8');
  late final _memset_pattern8 = _memset_pattern8Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern16(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern16,
    int __len,
  ) {
    return _memset_pattern16(
      __b,
      __pattern16,
      __len,
    );
  }

  late final _memset_pattern16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern16');
  late final _memset_pattern16 = _memset_pattern16Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strcasestr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strcasestr(
      __big,
      __little,
    );
  }

  late final _strcasestrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasestr');
  late final _strcasestr = _strcasestrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strnstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
    int __len,
  ) {
    return _strnstr(
      __big,
      __little,
      __len,
    );
  }

  late final _strnstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strnstr');
  late final _strnstr = _strnstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcat(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcat(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcat');
  late final _strlcat = _strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcpy(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcpy');
  late final _strlcpy = _strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void strmode(
    int __mode,
    ffi.Pointer<ffi.Char> __bp,
  ) {
    return _strmode(
      __mode,
      __bp,
    );
  }

  late final _strmodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'strmode');
  late final _strmode =
      _strmodePtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  void swab(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _swab(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _swabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ssize_t)>>('swab');
  late final _swab = _swabPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int timingsafe_bcmp(
    ffi.Pointer<ffi.Void> __b1,
    ffi.Pointer<ffi.Void> __b2,
    int __len,
  ) {
    return _timingsafe_bcmp(
      __b1,
      __b2,
      __len,
    );
  }

  late final _timingsafe_bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('timingsafe_bcmp');
  late final _timingsafe_bcmp = _timingsafe_bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int strsignal_r(
    int __sig,
    ffi.Pointer<ffi.Char> __strsignalbuf,
    int __buflen,
  ) {
    return _strsignal_r(
      __sig,
      __strsignalbuf,
      __buflen,
    );
  }

  late final _strsignal_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strsignal_r');
  late final _strsignal_r = _strsignal_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int bcmp(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Size)>>('bcmp');
  late final _bcmp = _bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bcopy(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcopy(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('bcopy');
  late final _bcopy = _bcopyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bzero(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return _bzero(
      arg0,
      arg1,
    );
  }

  late final _bzeroPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'bzero');
  late final _bzero =
      _bzeroPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> index(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _index(
      arg0,
      arg1,
    );
  }

  late final _indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('index');
  late final _index = _indexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> rindex(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _rindex(
      arg0,
      arg1,
    );
  }

  late final _rindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('rindex');
  late final _rindex = _rindexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int arg0,
  ) {
    return _ffs(
      arg0,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _strcasecmp(
      arg0,
      arg1,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _strncasecmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int ffsl(
    int arg0,
  ) {
    return _ffsl(
      arg0,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int arg0,
  ) {
    return _ffsll(
      arg0,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int fls(
    int arg0,
  ) {
    return _fls(
      arg0,
    );
  }

  late final _flsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fls');
  late final _fls = _flsPtr.asFunction<int Function(int)>();

  int flsl(
    int arg0,
  ) {
    return _flsl(
      arg0,
    );
  }

  late final _flslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('flsl');
  late final _flsl = _flslPtr.asFunction<int Function(int)>();

  int flsll(
    int arg0,
  ) {
    return _flsll(
      arg0,
    );
  }

  late final _flsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('flsll');
  late final _flsll = _flsllPtr.asFunction<int Function(int)>();

  void __assert_rtn(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return ___assert_rtn(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final ___assert_rtnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Char>)>>('__assert_rtn');
  late final ___assert_rtn = ___assert_rtnPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Char>)>();

  void wasm_byte_vec_new_empty(
    ffi.Pointer<wasm_byte_vec_t> out,
  ) {
    return _wasm_byte_vec_new_empty(
      out,
    );
  }

  late final _wasm_byte_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_byte_vec_t>)>>(
      'wasm_byte_vec_new_empty');
  late final _wasm_byte_vec_new_empty = _wasm_byte_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_byte_vec_t>)>();

  void wasm_byte_vec_new_uninitialized(
    ffi.Pointer<wasm_byte_vec_t> out,
    int arg1,
  ) {
    return _wasm_byte_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_byte_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_byte_vec_t>,
              ffi.Size)>>('wasm_byte_vec_new_uninitialized');
  late final _wasm_byte_vec_new_uninitialized =
      _wasm_byte_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_byte_vec_t>, int)>();

  void wasm_byte_vec_new(
    ffi.Pointer<wasm_byte_vec_t> out,
    int arg1,
    ffi.Pointer<wasm_byte_t> arg2,
  ) {
    return _wasm_byte_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_byte_vec_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_byte_vec_t>, ffi.Size,
              ffi.Pointer<wasm_byte_t>)>>('wasm_byte_vec_new');
  late final _wasm_byte_vec_new = _wasm_byte_vec_newPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_byte_vec_t>, int, ffi.Pointer<wasm_byte_t>)>();

  void wasm_byte_vec_copy(
    ffi.Pointer<wasm_byte_vec_t> out,
    ffi.Pointer<wasm_byte_vec_t> arg1,
  ) {
    return _wasm_byte_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_byte_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_byte_vec_t>,
              ffi.Pointer<wasm_byte_vec_t>)>>('wasm_byte_vec_copy');
  late final _wasm_byte_vec_copy = _wasm_byte_vec_copyPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_byte_vec_t>, ffi.Pointer<wasm_byte_vec_t>)>();

  void wasm_byte_vec_delete(
    ffi.Pointer<wasm_byte_vec_t> arg0,
  ) {
    return _wasm_byte_vec_delete(
      arg0,
    );
  }

  late final _wasm_byte_vec_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_byte_vec_t>)>>(
      'wasm_byte_vec_delete');
  late final _wasm_byte_vec_delete = _wasm_byte_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_byte_vec_t>)>();

  void wasm_config_delete(
    ffi.Pointer<wasm_config_t> arg0,
  ) {
    return _wasm_config_delete(
      arg0,
    );
  }

  late final _wasm_config_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_config_t>)>>(
      'wasm_config_delete');
  late final _wasm_config_delete = _wasm_config_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_config_t>)>();

  /// ////////////////////////////////////////////////////////////////////////////
  ffi.Pointer<wasm_config_t> wasm_config_new() {
    return _wasm_config_new();
  }

  late final _wasm_config_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wasm_config_t> Function()>>(
          'wasm_config_new');
  late final _wasm_config_new =
      _wasm_config_newPtr.asFunction<ffi.Pointer<wasm_config_t> Function()>();

  void wasm_engine_delete(
    ffi.Pointer<wasm_engine_t> arg0,
  ) {
    return _wasm_engine_delete(
      arg0,
    );
  }

  late final _wasm_engine_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_engine_t>)>>(
      'wasm_engine_delete');
  late final _wasm_engine_delete = _wasm_engine_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_engine_t>)>();

  ffi.Pointer<wasm_engine_t> wasm_engine_new() {
    return _wasm_engine_new();
  }

  late final _wasm_engine_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wasm_engine_t> Function()>>(
          'wasm_engine_new');
  late final _wasm_engine_new =
      _wasm_engine_newPtr.asFunction<ffi.Pointer<wasm_engine_t> Function()>();

  ffi.Pointer<wasm_engine_t> wasm_engine_new_with_config(
    ffi.Pointer<wasm_config_t> arg0,
  ) {
    return _wasm_engine_new_with_config(
      arg0,
    );
  }

  late final _wasm_engine_new_with_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_engine_t> Function(
              ffi.Pointer<wasm_config_t>)>>('wasm_engine_new_with_config');
  late final _wasm_engine_new_with_config =
      _wasm_engine_new_with_configPtr.asFunction<
          ffi.Pointer<wasm_engine_t> Function(ffi.Pointer<wasm_config_t>)>();

  void wasm_store_delete(
    ffi.Pointer<wasm_store_t> arg0,
  ) {
    return _wasm_store_delete(
      arg0,
    );
  }

  late final _wasm_store_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_store_t>)>>(
          'wasm_store_delete');
  late final _wasm_store_delete = _wasm_store_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_store_t>)>();

  ffi.Pointer<wasm_store_t> wasm_store_new(
    ffi.Pointer<wasm_engine_t> arg0,
  ) {
    return _wasm_store_new(
      arg0,
    );
  }

  late final _wasm_store_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_store_t> Function(
              ffi.Pointer<wasm_engine_t>)>>('wasm_store_new');
  late final _wasm_store_new = _wasm_store_newPtr.asFunction<
      ffi.Pointer<wasm_store_t> Function(ffi.Pointer<wasm_engine_t>)>();

  late final ffi.Pointer<ffi.Uint32> _wasm_limits_max_default =
      _lookup<ffi.Uint32>('wasm_limits_max_default');

  int get wasm_limits_max_default => _wasm_limits_max_default.value;

  set wasm_limits_max_default(int value) =>
      _wasm_limits_max_default.value = value;

  void wasm_valtype_delete(
    ffi.Pointer<wasm_valtype_t> arg0,
  ) {
    return _wasm_valtype_delete(
      arg0,
    );
  }

  late final _wasm_valtype_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_valtype_t>)>>(
      'wasm_valtype_delete');
  late final _wasm_valtype_delete = _wasm_valtype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_valtype_t>)>();

  void wasm_valtype_vec_new_empty(
    ffi.Pointer<wasm_valtype_vec_t> out,
  ) {
    return _wasm_valtype_vec_new_empty(
      out,
    );
  }

  late final _wasm_valtype_vec_new_emptyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_valtype_vec_t>)>>(
      'wasm_valtype_vec_new_empty');
  late final _wasm_valtype_vec_new_empty = _wasm_valtype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_valtype_vec_t>)>();

  void wasm_valtype_vec_new_uninitialized(
    ffi.Pointer<wasm_valtype_vec_t> out,
    int arg1,
  ) {
    return _wasm_valtype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_valtype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_valtype_vec_t>,
              ffi.Size)>>('wasm_valtype_vec_new_uninitialized');
  late final _wasm_valtype_vec_new_uninitialized =
      _wasm_valtype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_valtype_vec_t>, int)>();

  void wasm_valtype_vec_new(
    ffi.Pointer<wasm_valtype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_valtype_t>> arg2,
  ) {
    return _wasm_valtype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_valtype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_valtype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_valtype_t>>)>>(
      'wasm_valtype_vec_new');
  late final _wasm_valtype_vec_new = _wasm_valtype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_valtype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_valtype_t>>)>();

  void wasm_valtype_vec_copy(
    ffi.Pointer<wasm_valtype_vec_t> out,
    ffi.Pointer<wasm_valtype_vec_t> arg1,
  ) {
    return _wasm_valtype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_valtype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_valtype_vec_t>,
              ffi.Pointer<wasm_valtype_vec_t>)>>('wasm_valtype_vec_copy');
  late final _wasm_valtype_vec_copy = _wasm_valtype_vec_copyPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_valtype_vec_t>, ffi.Pointer<wasm_valtype_vec_t>)>();

  void wasm_valtype_vec_delete(
    ffi.Pointer<wasm_valtype_vec_t> arg0,
  ) {
    return _wasm_valtype_vec_delete(
      arg0,
    );
  }

  late final _wasm_valtype_vec_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_valtype_vec_t>)>>(
      'wasm_valtype_vec_delete');
  late final _wasm_valtype_vec_delete = _wasm_valtype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_valtype_vec_t>)>();

  ffi.Pointer<wasm_valtype_t> wasm_valtype_copy(
    ffi.Pointer<wasm_valtype_t> arg0,
  ) {
    return _wasm_valtype_copy(
      arg0,
    );
  }

  late final _wasm_valtype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_valtype_t> Function(
              ffi.Pointer<wasm_valtype_t>)>>('wasm_valtype_copy');
  late final _wasm_valtype_copy = _wasm_valtype_copyPtr.asFunction<
      ffi.Pointer<wasm_valtype_t> Function(ffi.Pointer<wasm_valtype_t>)>();

  ffi.Pointer<wasm_valtype_t> wasm_valtype_new(
    int arg0,
  ) {
    return _wasm_valtype_new(
      arg0,
    );
  }

  late final _wasm_valtype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_valtype_t> Function(
              wasm_valkind_t)>>('wasm_valtype_new');
  late final _wasm_valtype_new = _wasm_valtype_newPtr
      .asFunction<ffi.Pointer<wasm_valtype_t> Function(int)>();

  int wasm_valtype_kind(
    ffi.Pointer<wasm_valtype_t> arg0,
  ) {
    return _wasm_valtype_kind(
      arg0,
    );
  }

  late final _wasm_valtype_kindPtr = _lookup<
      ffi.NativeFunction<
          wasm_valkind_t Function(
              ffi.Pointer<wasm_valtype_t>)>>('wasm_valtype_kind');
  late final _wasm_valtype_kind = _wasm_valtype_kindPtr
      .asFunction<int Function(ffi.Pointer<wasm_valtype_t>)>();

  void wasm_functype_delete(
    ffi.Pointer<wasm_functype_t> arg0,
  ) {
    return _wasm_functype_delete(
      arg0,
    );
  }

  late final _wasm_functype_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_functype_t>)>>(
      'wasm_functype_delete');
  late final _wasm_functype_delete = _wasm_functype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_functype_t>)>();

  void wasm_functype_vec_new_empty(
    ffi.Pointer<wasm_functype_vec_t> out,
  ) {
    return _wasm_functype_vec_new_empty(
      out,
    );
  }

  late final _wasm_functype_vec_new_emptyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_functype_vec_t>)>>(
      'wasm_functype_vec_new_empty');
  late final _wasm_functype_vec_new_empty = _wasm_functype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_functype_vec_t>)>();

  void wasm_functype_vec_new_uninitialized(
    ffi.Pointer<wasm_functype_vec_t> out,
    int arg1,
  ) {
    return _wasm_functype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_functype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_functype_vec_t>,
              ffi.Size)>>('wasm_functype_vec_new_uninitialized');
  late final _wasm_functype_vec_new_uninitialized =
      _wasm_functype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_functype_vec_t>, int)>();

  void wasm_functype_vec_new(
    ffi.Pointer<wasm_functype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_functype_t>> arg2,
  ) {
    return _wasm_functype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_functype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_functype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_functype_t>>)>>(
      'wasm_functype_vec_new');
  late final _wasm_functype_vec_new = _wasm_functype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_functype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_functype_t>>)>();

  void wasm_functype_vec_copy(
    ffi.Pointer<wasm_functype_vec_t> out,
    ffi.Pointer<wasm_functype_vec_t> arg1,
  ) {
    return _wasm_functype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_functype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_functype_vec_t>,
              ffi.Pointer<wasm_functype_vec_t>)>>('wasm_functype_vec_copy');
  late final _wasm_functype_vec_copy = _wasm_functype_vec_copyPtr.asFunction<
      void Function(ffi.Pointer<wasm_functype_vec_t>,
          ffi.Pointer<wasm_functype_vec_t>)>();

  void wasm_functype_vec_delete(
    ffi.Pointer<wasm_functype_vec_t> arg0,
  ) {
    return _wasm_functype_vec_delete(
      arg0,
    );
  }

  late final _wasm_functype_vec_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_functype_vec_t>)>>(
      'wasm_functype_vec_delete');
  late final _wasm_functype_vec_delete = _wasm_functype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_functype_vec_t>)>();

  ffi.Pointer<wasm_functype_t> wasm_functype_copy(
    ffi.Pointer<wasm_functype_t> arg0,
  ) {
    return _wasm_functype_copy(
      arg0,
    );
  }

  late final _wasm_functype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_functype_t> Function(
              ffi.Pointer<wasm_functype_t>)>>('wasm_functype_copy');
  late final _wasm_functype_copy = _wasm_functype_copyPtr.asFunction<
      ffi.Pointer<wasm_functype_t> Function(ffi.Pointer<wasm_functype_t>)>();

  ffi.Pointer<wasm_functype_t> wasm_functype_new(
    ffi.Pointer<wasm_valtype_vec_t> params,
    ffi.Pointer<wasm_valtype_vec_t> results,
  ) {
    return _wasm_functype_new(
      params,
      results,
    );
  }

  late final _wasm_functype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_functype_t> Function(ffi.Pointer<wasm_valtype_vec_t>,
              ffi.Pointer<wasm_valtype_vec_t>)>>('wasm_functype_new');
  late final _wasm_functype_new = _wasm_functype_newPtr.asFunction<
      ffi.Pointer<wasm_functype_t> Function(
          ffi.Pointer<wasm_valtype_vec_t>, ffi.Pointer<wasm_valtype_vec_t>)>();

  ffi.Pointer<wasm_valtype_vec_t> wasm_functype_params(
    ffi.Pointer<wasm_functype_t> arg0,
  ) {
    return _wasm_functype_params(
      arg0,
    );
  }

  late final _wasm_functype_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_valtype_vec_t> Function(
              ffi.Pointer<wasm_functype_t>)>>('wasm_functype_params');
  late final _wasm_functype_params = _wasm_functype_paramsPtr.asFunction<
      ffi.Pointer<wasm_valtype_vec_t> Function(ffi.Pointer<wasm_functype_t>)>();

  ffi.Pointer<wasm_valtype_vec_t> wasm_functype_results(
    ffi.Pointer<wasm_functype_t> arg0,
  ) {
    return _wasm_functype_results(
      arg0,
    );
  }

  late final _wasm_functype_resultsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_valtype_vec_t> Function(
              ffi.Pointer<wasm_functype_t>)>>('wasm_functype_results');
  late final _wasm_functype_results = _wasm_functype_resultsPtr.asFunction<
      ffi.Pointer<wasm_valtype_vec_t> Function(ffi.Pointer<wasm_functype_t>)>();

  void wasm_globaltype_delete(
    ffi.Pointer<wasm_globaltype_t> arg0,
  ) {
    return _wasm_globaltype_delete(
      arg0,
    );
  }

  late final _wasm_globaltype_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_globaltype_t>)>>(
      'wasm_globaltype_delete');
  late final _wasm_globaltype_delete = _wasm_globaltype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_globaltype_t>)>();

  void wasm_globaltype_vec_new_empty(
    ffi.Pointer<wasm_globaltype_vec_t> out,
  ) {
    return _wasm_globaltype_vec_new_empty(
      out,
    );
  }

  late final _wasm_globaltype_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_globaltype_vec_t>)>>(
      'wasm_globaltype_vec_new_empty');
  late final _wasm_globaltype_vec_new_empty = _wasm_globaltype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_globaltype_vec_t>)>();

  void wasm_globaltype_vec_new_uninitialized(
    ffi.Pointer<wasm_globaltype_vec_t> out,
    int arg1,
  ) {
    return _wasm_globaltype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_globaltype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_globaltype_vec_t>,
              ffi.Size)>>('wasm_globaltype_vec_new_uninitialized');
  late final _wasm_globaltype_vec_new_uninitialized =
      _wasm_globaltype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_globaltype_vec_t>, int)>();

  void wasm_globaltype_vec_new(
    ffi.Pointer<wasm_globaltype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_globaltype_t>> arg2,
  ) {
    return _wasm_globaltype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_globaltype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_globaltype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_globaltype_t>>)>>(
      'wasm_globaltype_vec_new');
  late final _wasm_globaltype_vec_new = _wasm_globaltype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_globaltype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_globaltype_t>>)>();

  void wasm_globaltype_vec_copy(
    ffi.Pointer<wasm_globaltype_vec_t> out,
    ffi.Pointer<wasm_globaltype_vec_t> arg1,
  ) {
    return _wasm_globaltype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_globaltype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_globaltype_vec_t>,
              ffi.Pointer<wasm_globaltype_vec_t>)>>('wasm_globaltype_vec_copy');
  late final _wasm_globaltype_vec_copy =
      _wasm_globaltype_vec_copyPtr.asFunction<
          void Function(ffi.Pointer<wasm_globaltype_vec_t>,
              ffi.Pointer<wasm_globaltype_vec_t>)>();

  void wasm_globaltype_vec_delete(
    ffi.Pointer<wasm_globaltype_vec_t> arg0,
  ) {
    return _wasm_globaltype_vec_delete(
      arg0,
    );
  }

  late final _wasm_globaltype_vec_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_globaltype_vec_t>)>>(
      'wasm_globaltype_vec_delete');
  late final _wasm_globaltype_vec_delete = _wasm_globaltype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_globaltype_vec_t>)>();

  ffi.Pointer<wasm_globaltype_t> wasm_globaltype_copy(
    ffi.Pointer<wasm_globaltype_t> arg0,
  ) {
    return _wasm_globaltype_copy(
      arg0,
    );
  }

  late final _wasm_globaltype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_globaltype_t> Function(
              ffi.Pointer<wasm_globaltype_t>)>>('wasm_globaltype_copy');
  late final _wasm_globaltype_copy = _wasm_globaltype_copyPtr.asFunction<
      ffi.Pointer<wasm_globaltype_t> Function(
          ffi.Pointer<wasm_globaltype_t>)>();

  ffi.Pointer<wasm_globaltype_t> wasm_globaltype_new(
    ffi.Pointer<wasm_valtype_t> arg0,
    int arg1,
  ) {
    return _wasm_globaltype_new(
      arg0,
      arg1,
    );
  }

  late final _wasm_globaltype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_globaltype_t> Function(ffi.Pointer<wasm_valtype_t>,
              wasm_mutability_t)>>('wasm_globaltype_new');
  late final _wasm_globaltype_new = _wasm_globaltype_newPtr.asFunction<
      ffi.Pointer<wasm_globaltype_t> Function(
          ffi.Pointer<wasm_valtype_t>, int)>();

  ffi.Pointer<wasm_valtype_t> wasm_globaltype_content(
    ffi.Pointer<wasm_globaltype_t> arg0,
  ) {
    return _wasm_globaltype_content(
      arg0,
    );
  }

  late final _wasm_globaltype_contentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_valtype_t> Function(
              ffi.Pointer<wasm_globaltype_t>)>>('wasm_globaltype_content');
  late final _wasm_globaltype_content = _wasm_globaltype_contentPtr.asFunction<
      ffi.Pointer<wasm_valtype_t> Function(ffi.Pointer<wasm_globaltype_t>)>();

  int wasm_globaltype_mutability(
    ffi.Pointer<wasm_globaltype_t> arg0,
  ) {
    return _wasm_globaltype_mutability(
      arg0,
    );
  }

  late final _wasm_globaltype_mutabilityPtr = _lookup<
      ffi.NativeFunction<
          wasm_mutability_t Function(
              ffi.Pointer<wasm_globaltype_t>)>>('wasm_globaltype_mutability');
  late final _wasm_globaltype_mutability = _wasm_globaltype_mutabilityPtr
      .asFunction<int Function(ffi.Pointer<wasm_globaltype_t>)>();

  void wasm_tabletype_delete(
    ffi.Pointer<wasm_tabletype_t> arg0,
  ) {
    return _wasm_tabletype_delete(
      arg0,
    );
  }

  late final _wasm_tabletype_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_tabletype_t>)>>(
      'wasm_tabletype_delete');
  late final _wasm_tabletype_delete = _wasm_tabletype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_tabletype_t>)>();

  void wasm_tabletype_vec_new_empty(
    ffi.Pointer<wasm_tabletype_vec_t> out,
  ) {
    return _wasm_tabletype_vec_new_empty(
      out,
    );
  }

  late final _wasm_tabletype_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_tabletype_vec_t>)>>(
      'wasm_tabletype_vec_new_empty');
  late final _wasm_tabletype_vec_new_empty = _wasm_tabletype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_tabletype_vec_t>)>();

  void wasm_tabletype_vec_new_uninitialized(
    ffi.Pointer<wasm_tabletype_vec_t> out,
    int arg1,
  ) {
    return _wasm_tabletype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_tabletype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_tabletype_vec_t>,
              ffi.Size)>>('wasm_tabletype_vec_new_uninitialized');
  late final _wasm_tabletype_vec_new_uninitialized =
      _wasm_tabletype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_tabletype_vec_t>, int)>();

  void wasm_tabletype_vec_new(
    ffi.Pointer<wasm_tabletype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_tabletype_t>> arg2,
  ) {
    return _wasm_tabletype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_tabletype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_tabletype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_tabletype_t>>)>>(
      'wasm_tabletype_vec_new');
  late final _wasm_tabletype_vec_new = _wasm_tabletype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_tabletype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_tabletype_t>>)>();

  void wasm_tabletype_vec_copy(
    ffi.Pointer<wasm_tabletype_vec_t> out,
    ffi.Pointer<wasm_tabletype_vec_t> arg1,
  ) {
    return _wasm_tabletype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_tabletype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_tabletype_vec_t>,
              ffi.Pointer<wasm_tabletype_vec_t>)>>('wasm_tabletype_vec_copy');
  late final _wasm_tabletype_vec_copy = _wasm_tabletype_vec_copyPtr.asFunction<
      void Function(ffi.Pointer<wasm_tabletype_vec_t>,
          ffi.Pointer<wasm_tabletype_vec_t>)>();

  void wasm_tabletype_vec_delete(
    ffi.Pointer<wasm_tabletype_vec_t> arg0,
  ) {
    return _wasm_tabletype_vec_delete(
      arg0,
    );
  }

  late final _wasm_tabletype_vec_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasm_tabletype_vec_t>)>>('wasm_tabletype_vec_delete');
  late final _wasm_tabletype_vec_delete = _wasm_tabletype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_tabletype_vec_t>)>();

  ffi.Pointer<wasm_tabletype_t> wasm_tabletype_copy(
    ffi.Pointer<wasm_tabletype_t> arg0,
  ) {
    return _wasm_tabletype_copy(
      arg0,
    );
  }

  late final _wasm_tabletype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_tabletype_t> Function(
              ffi.Pointer<wasm_tabletype_t>)>>('wasm_tabletype_copy');
  late final _wasm_tabletype_copy = _wasm_tabletype_copyPtr.asFunction<
      ffi.Pointer<wasm_tabletype_t> Function(ffi.Pointer<wasm_tabletype_t>)>();

  ffi.Pointer<wasm_tabletype_t> wasm_tabletype_new(
    ffi.Pointer<wasm_valtype_t> arg0,
    ffi.Pointer<wasm_limits_t> arg1,
  ) {
    return _wasm_tabletype_new(
      arg0,
      arg1,
    );
  }

  late final _wasm_tabletype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_tabletype_t> Function(ffi.Pointer<wasm_valtype_t>,
              ffi.Pointer<wasm_limits_t>)>>('wasm_tabletype_new');
  late final _wasm_tabletype_new = _wasm_tabletype_newPtr.asFunction<
      ffi.Pointer<wasm_tabletype_t> Function(
          ffi.Pointer<wasm_valtype_t>, ffi.Pointer<wasm_limits_t>)>();

  ffi.Pointer<wasm_valtype_t> wasm_tabletype_element(
    ffi.Pointer<wasm_tabletype_t> arg0,
  ) {
    return _wasm_tabletype_element(
      arg0,
    );
  }

  late final _wasm_tabletype_elementPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_valtype_t> Function(
              ffi.Pointer<wasm_tabletype_t>)>>('wasm_tabletype_element');
  late final _wasm_tabletype_element = _wasm_tabletype_elementPtr.asFunction<
      ffi.Pointer<wasm_valtype_t> Function(ffi.Pointer<wasm_tabletype_t>)>();

  ffi.Pointer<wasm_limits_t> wasm_tabletype_limits(
    ffi.Pointer<wasm_tabletype_t> arg0,
  ) {
    return _wasm_tabletype_limits(
      arg0,
    );
  }

  late final _wasm_tabletype_limitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_limits_t> Function(
              ffi.Pointer<wasm_tabletype_t>)>>('wasm_tabletype_limits');
  late final _wasm_tabletype_limits = _wasm_tabletype_limitsPtr.asFunction<
      ffi.Pointer<wasm_limits_t> Function(ffi.Pointer<wasm_tabletype_t>)>();

  void wasm_memorytype_delete(
    ffi.Pointer<wasm_memorytype_t> arg0,
  ) {
    return _wasm_memorytype_delete(
      arg0,
    );
  }

  late final _wasm_memorytype_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_memorytype_t>)>>(
      'wasm_memorytype_delete');
  late final _wasm_memorytype_delete = _wasm_memorytype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_memorytype_t>)>();

  void wasm_memorytype_vec_new_empty(
    ffi.Pointer<wasm_memorytype_vec_t> out,
  ) {
    return _wasm_memorytype_vec_new_empty(
      out,
    );
  }

  late final _wasm_memorytype_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_memorytype_vec_t>)>>(
      'wasm_memorytype_vec_new_empty');
  late final _wasm_memorytype_vec_new_empty = _wasm_memorytype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_memorytype_vec_t>)>();

  void wasm_memorytype_vec_new_uninitialized(
    ffi.Pointer<wasm_memorytype_vec_t> out,
    int arg1,
  ) {
    return _wasm_memorytype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_memorytype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_memorytype_vec_t>,
              ffi.Size)>>('wasm_memorytype_vec_new_uninitialized');
  late final _wasm_memorytype_vec_new_uninitialized =
      _wasm_memorytype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_memorytype_vec_t>, int)>();

  void wasm_memorytype_vec_new(
    ffi.Pointer<wasm_memorytype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_memorytype_t>> arg2,
  ) {
    return _wasm_memorytype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_memorytype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_memorytype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_memorytype_t>>)>>(
      'wasm_memorytype_vec_new');
  late final _wasm_memorytype_vec_new = _wasm_memorytype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_memorytype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_memorytype_t>>)>();

  void wasm_memorytype_vec_copy(
    ffi.Pointer<wasm_memorytype_vec_t> out,
    ffi.Pointer<wasm_memorytype_vec_t> arg1,
  ) {
    return _wasm_memorytype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_memorytype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_memorytype_vec_t>,
              ffi.Pointer<wasm_memorytype_vec_t>)>>('wasm_memorytype_vec_copy');
  late final _wasm_memorytype_vec_copy =
      _wasm_memorytype_vec_copyPtr.asFunction<
          void Function(ffi.Pointer<wasm_memorytype_vec_t>,
              ffi.Pointer<wasm_memorytype_vec_t>)>();

  void wasm_memorytype_vec_delete(
    ffi.Pointer<wasm_memorytype_vec_t> arg0,
  ) {
    return _wasm_memorytype_vec_delete(
      arg0,
    );
  }

  late final _wasm_memorytype_vec_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_memorytype_vec_t>)>>(
      'wasm_memorytype_vec_delete');
  late final _wasm_memorytype_vec_delete = _wasm_memorytype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_memorytype_vec_t>)>();

  ffi.Pointer<wasm_memorytype_t> wasm_memorytype_copy(
    ffi.Pointer<wasm_memorytype_t> arg0,
  ) {
    return _wasm_memorytype_copy(
      arg0,
    );
  }

  late final _wasm_memorytype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memorytype_t> Function(
              ffi.Pointer<wasm_memorytype_t>)>>('wasm_memorytype_copy');
  late final _wasm_memorytype_copy = _wasm_memorytype_copyPtr.asFunction<
      ffi.Pointer<wasm_memorytype_t> Function(
          ffi.Pointer<wasm_memorytype_t>)>();

  ffi.Pointer<wasm_memorytype_t> wasm_memorytype_new(
    ffi.Pointer<wasm_limits_t> arg0,
  ) {
    return _wasm_memorytype_new(
      arg0,
    );
  }

  late final _wasm_memorytype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memorytype_t> Function(
              ffi.Pointer<wasm_limits_t>)>>('wasm_memorytype_new');
  late final _wasm_memorytype_new = _wasm_memorytype_newPtr.asFunction<
      ffi.Pointer<wasm_memorytype_t> Function(ffi.Pointer<wasm_limits_t>)>();

  ffi.Pointer<wasm_limits_t> wasm_memorytype_limits(
    ffi.Pointer<wasm_memorytype_t> arg0,
  ) {
    return _wasm_memorytype_limits(
      arg0,
    );
  }

  late final _wasm_memorytype_limitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_limits_t> Function(
              ffi.Pointer<wasm_memorytype_t>)>>('wasm_memorytype_limits');
  late final _wasm_memorytype_limits = _wasm_memorytype_limitsPtr.asFunction<
      ffi.Pointer<wasm_limits_t> Function(ffi.Pointer<wasm_memorytype_t>)>();

  void wasm_externtype_delete(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_delete(
      arg0,
    );
  }

  late final _wasm_externtype_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_externtype_t>)>>(
      'wasm_externtype_delete');
  late final _wasm_externtype_delete = _wasm_externtype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_externtype_t>)>();

  void wasm_externtype_vec_new_empty(
    ffi.Pointer<wasm_externtype_vec_t> out,
  ) {
    return _wasm_externtype_vec_new_empty(
      out,
    );
  }

  late final _wasm_externtype_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_externtype_vec_t>)>>(
      'wasm_externtype_vec_new_empty');
  late final _wasm_externtype_vec_new_empty = _wasm_externtype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_externtype_vec_t>)>();

  void wasm_externtype_vec_new_uninitialized(
    ffi.Pointer<wasm_externtype_vec_t> out,
    int arg1,
  ) {
    return _wasm_externtype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_externtype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_externtype_vec_t>,
              ffi.Size)>>('wasm_externtype_vec_new_uninitialized');
  late final _wasm_externtype_vec_new_uninitialized =
      _wasm_externtype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_externtype_vec_t>, int)>();

  void wasm_externtype_vec_new(
    ffi.Pointer<wasm_externtype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_externtype_t>> arg2,
  ) {
    return _wasm_externtype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_externtype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_externtype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_externtype_t>>)>>(
      'wasm_externtype_vec_new');
  late final _wasm_externtype_vec_new = _wasm_externtype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_externtype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_externtype_t>>)>();

  void wasm_externtype_vec_copy(
    ffi.Pointer<wasm_externtype_vec_t> out,
    ffi.Pointer<wasm_externtype_vec_t> arg1,
  ) {
    return _wasm_externtype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_externtype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_externtype_vec_t>,
              ffi.Pointer<wasm_externtype_vec_t>)>>('wasm_externtype_vec_copy');
  late final _wasm_externtype_vec_copy =
      _wasm_externtype_vec_copyPtr.asFunction<
          void Function(ffi.Pointer<wasm_externtype_vec_t>,
              ffi.Pointer<wasm_externtype_vec_t>)>();

  void wasm_externtype_vec_delete(
    ffi.Pointer<wasm_externtype_vec_t> arg0,
  ) {
    return _wasm_externtype_vec_delete(
      arg0,
    );
  }

  late final _wasm_externtype_vec_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_externtype_vec_t>)>>(
      'wasm_externtype_vec_delete');
  late final _wasm_externtype_vec_delete = _wasm_externtype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_externtype_vec_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_externtype_copy(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_copy(
      arg0,
    );
  }

  late final _wasm_externtype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>>('wasm_externtype_copy');
  late final _wasm_externtype_copy = _wasm_externtype_copyPtr.asFunction<
      ffi.Pointer<wasm_externtype_t> Function(
          ffi.Pointer<wasm_externtype_t>)>();

  int wasm_externtype_kind(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_kind(
      arg0,
    );
  }

  late final _wasm_externtype_kindPtr = _lookup<
      ffi.NativeFunction<
          wasm_externkind_t Function(
              ffi.Pointer<wasm_externtype_t>)>>('wasm_externtype_kind');
  late final _wasm_externtype_kind = _wasm_externtype_kindPtr
      .asFunction<int Function(ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_functype_as_externtype(
    ffi.Pointer<wasm_functype_t> arg0,
  ) {
    return _wasm_functype_as_externtype(
      arg0,
    );
  }

  late final _wasm_functype_as_externtypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_functype_t>)>>('wasm_functype_as_externtype');
  late final _wasm_functype_as_externtype =
      _wasm_functype_as_externtypePtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_functype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_globaltype_as_externtype(
    ffi.Pointer<wasm_globaltype_t> arg0,
  ) {
    return _wasm_globaltype_as_externtype(
      arg0,
    );
  }

  late final _wasm_globaltype_as_externtypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_externtype_t> Function(
                  ffi.Pointer<wasm_globaltype_t>)>>(
      'wasm_globaltype_as_externtype');
  late final _wasm_globaltype_as_externtype =
      _wasm_globaltype_as_externtypePtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_globaltype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_tabletype_as_externtype(
    ffi.Pointer<wasm_tabletype_t> arg0,
  ) {
    return _wasm_tabletype_as_externtype(
      arg0,
    );
  }

  late final _wasm_tabletype_as_externtypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_tabletype_t>)>>('wasm_tabletype_as_externtype');
  late final _wasm_tabletype_as_externtype =
      _wasm_tabletype_as_externtypePtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_tabletype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_memorytype_as_externtype(
    ffi.Pointer<wasm_memorytype_t> arg0,
  ) {
    return _wasm_memorytype_as_externtype(
      arg0,
    );
  }

  late final _wasm_memorytype_as_externtypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_externtype_t> Function(
                  ffi.Pointer<wasm_memorytype_t>)>>(
      'wasm_memorytype_as_externtype');
  late final _wasm_memorytype_as_externtype =
      _wasm_memorytype_as_externtypePtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_memorytype_t>)>();

  ffi.Pointer<wasm_functype_t> wasm_externtype_as_functype(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_functype(
      arg0,
    );
  }

  late final _wasm_externtype_as_functypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_functype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>>('wasm_externtype_as_functype');
  late final _wasm_externtype_as_functype =
      _wasm_externtype_as_functypePtr.asFunction<
          ffi.Pointer<wasm_functype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_globaltype_t> wasm_externtype_as_globaltype(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_globaltype(
      arg0,
    );
  }

  late final _wasm_externtype_as_globaltypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_globaltype_t> Function(
                  ffi.Pointer<wasm_externtype_t>)>>(
      'wasm_externtype_as_globaltype');
  late final _wasm_externtype_as_globaltype =
      _wasm_externtype_as_globaltypePtr.asFunction<
          ffi.Pointer<wasm_globaltype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_tabletype_t> wasm_externtype_as_tabletype(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_tabletype(
      arg0,
    );
  }

  late final _wasm_externtype_as_tabletypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_tabletype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>>('wasm_externtype_as_tabletype');
  late final _wasm_externtype_as_tabletype =
      _wasm_externtype_as_tabletypePtr.asFunction<
          ffi.Pointer<wasm_tabletype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_memorytype_t> wasm_externtype_as_memorytype(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_memorytype(
      arg0,
    );
  }

  late final _wasm_externtype_as_memorytypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_memorytype_t> Function(
                  ffi.Pointer<wasm_externtype_t>)>>(
      'wasm_externtype_as_memorytype');
  late final _wasm_externtype_as_memorytype =
      _wasm_externtype_as_memorytypePtr.asFunction<
          ffi.Pointer<wasm_memorytype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_functype_as_externtype_const(
    ffi.Pointer<wasm_functype_t> arg0,
  ) {
    return _wasm_functype_as_externtype_const(
      arg0,
    );
  }

  late final _wasm_functype_as_externtype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_externtype_t> Function(
                  ffi.Pointer<wasm_functype_t>)>>(
      'wasm_functype_as_externtype_const');
  late final _wasm_functype_as_externtype_const =
      _wasm_functype_as_externtype_constPtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_functype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_globaltype_as_externtype_const(
    ffi.Pointer<wasm_globaltype_t> arg0,
  ) {
    return _wasm_globaltype_as_externtype_const(
      arg0,
    );
  }

  late final _wasm_globaltype_as_externtype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_externtype_t> Function(
                  ffi.Pointer<wasm_globaltype_t>)>>(
      'wasm_globaltype_as_externtype_const');
  late final _wasm_globaltype_as_externtype_const =
      _wasm_globaltype_as_externtype_constPtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_globaltype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_tabletype_as_externtype_const(
    ffi.Pointer<wasm_tabletype_t> arg0,
  ) {
    return _wasm_tabletype_as_externtype_const(
      arg0,
    );
  }

  late final _wasm_tabletype_as_externtype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_externtype_t> Function(
                  ffi.Pointer<wasm_tabletype_t>)>>(
      'wasm_tabletype_as_externtype_const');
  late final _wasm_tabletype_as_externtype_const =
      _wasm_tabletype_as_externtype_constPtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_tabletype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_memorytype_as_externtype_const(
    ffi.Pointer<wasm_memorytype_t> arg0,
  ) {
    return _wasm_memorytype_as_externtype_const(
      arg0,
    );
  }

  late final _wasm_memorytype_as_externtype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_externtype_t> Function(
                  ffi.Pointer<wasm_memorytype_t>)>>(
      'wasm_memorytype_as_externtype_const');
  late final _wasm_memorytype_as_externtype_const =
      _wasm_memorytype_as_externtype_constPtr.asFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_memorytype_t>)>();

  ffi.Pointer<wasm_functype_t> wasm_externtype_as_functype_const(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_functype_const(
      arg0,
    );
  }

  late final _wasm_externtype_as_functype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_functype_t> Function(
                  ffi.Pointer<wasm_externtype_t>)>>(
      'wasm_externtype_as_functype_const');
  late final _wasm_externtype_as_functype_const =
      _wasm_externtype_as_functype_constPtr.asFunction<
          ffi.Pointer<wasm_functype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_globaltype_t> wasm_externtype_as_globaltype_const(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_globaltype_const(
      arg0,
    );
  }

  late final _wasm_externtype_as_globaltype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_globaltype_t> Function(
                  ffi.Pointer<wasm_externtype_t>)>>(
      'wasm_externtype_as_globaltype_const');
  late final _wasm_externtype_as_globaltype_const =
      _wasm_externtype_as_globaltype_constPtr.asFunction<
          ffi.Pointer<wasm_globaltype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_tabletype_t> wasm_externtype_as_tabletype_const(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_tabletype_const(
      arg0,
    );
  }

  late final _wasm_externtype_as_tabletype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_tabletype_t> Function(
                  ffi.Pointer<wasm_externtype_t>)>>(
      'wasm_externtype_as_tabletype_const');
  late final _wasm_externtype_as_tabletype_const =
      _wasm_externtype_as_tabletype_constPtr.asFunction<
          ffi.Pointer<wasm_tabletype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_memorytype_t> wasm_externtype_as_memorytype_const(
    ffi.Pointer<wasm_externtype_t> arg0,
  ) {
    return _wasm_externtype_as_memorytype_const(
      arg0,
    );
  }

  late final _wasm_externtype_as_memorytype_constPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasm_memorytype_t> Function(
                  ffi.Pointer<wasm_externtype_t>)>>(
      'wasm_externtype_as_memorytype_const');
  late final _wasm_externtype_as_memorytype_const =
      _wasm_externtype_as_memorytype_constPtr.asFunction<
          ffi.Pointer<wasm_memorytype_t> Function(
              ffi.Pointer<wasm_externtype_t>)>();

  void wasm_importtype_delete(
    ffi.Pointer<wasm_importtype_t> arg0,
  ) {
    return _wasm_importtype_delete(
      arg0,
    );
  }

  late final _wasm_importtype_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_importtype_t>)>>(
      'wasm_importtype_delete');
  late final _wasm_importtype_delete = _wasm_importtype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_importtype_t>)>();

  void wasm_importtype_vec_new_empty(
    ffi.Pointer<wasm_importtype_vec_t> out,
  ) {
    return _wasm_importtype_vec_new_empty(
      out,
    );
  }

  late final _wasm_importtype_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_importtype_vec_t>)>>(
      'wasm_importtype_vec_new_empty');
  late final _wasm_importtype_vec_new_empty = _wasm_importtype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_importtype_vec_t>)>();

  void wasm_importtype_vec_new_uninitialized(
    ffi.Pointer<wasm_importtype_vec_t> out,
    int arg1,
  ) {
    return _wasm_importtype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_importtype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_importtype_vec_t>,
              ffi.Size)>>('wasm_importtype_vec_new_uninitialized');
  late final _wasm_importtype_vec_new_uninitialized =
      _wasm_importtype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_importtype_vec_t>, int)>();

  void wasm_importtype_vec_new(
    ffi.Pointer<wasm_importtype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_importtype_t>> arg2,
  ) {
    return _wasm_importtype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_importtype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_importtype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_importtype_t>>)>>(
      'wasm_importtype_vec_new');
  late final _wasm_importtype_vec_new = _wasm_importtype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_importtype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_importtype_t>>)>();

  void wasm_importtype_vec_copy(
    ffi.Pointer<wasm_importtype_vec_t> out,
    ffi.Pointer<wasm_importtype_vec_t> arg1,
  ) {
    return _wasm_importtype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_importtype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_importtype_vec_t>,
              ffi.Pointer<wasm_importtype_vec_t>)>>('wasm_importtype_vec_copy');
  late final _wasm_importtype_vec_copy =
      _wasm_importtype_vec_copyPtr.asFunction<
          void Function(ffi.Pointer<wasm_importtype_vec_t>,
              ffi.Pointer<wasm_importtype_vec_t>)>();

  void wasm_importtype_vec_delete(
    ffi.Pointer<wasm_importtype_vec_t> arg0,
  ) {
    return _wasm_importtype_vec_delete(
      arg0,
    );
  }

  late final _wasm_importtype_vec_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_importtype_vec_t>)>>(
      'wasm_importtype_vec_delete');
  late final _wasm_importtype_vec_delete = _wasm_importtype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_importtype_vec_t>)>();

  ffi.Pointer<wasm_importtype_t> wasm_importtype_copy(
    ffi.Pointer<wasm_importtype_t> arg0,
  ) {
    return _wasm_importtype_copy(
      arg0,
    );
  }

  late final _wasm_importtype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_importtype_t> Function(
              ffi.Pointer<wasm_importtype_t>)>>('wasm_importtype_copy');
  late final _wasm_importtype_copy = _wasm_importtype_copyPtr.asFunction<
      ffi.Pointer<wasm_importtype_t> Function(
          ffi.Pointer<wasm_importtype_t>)>();

  ffi.Pointer<wasm_importtype_t> wasm_importtype_new(
    ffi.Pointer<wasm_name_t> module,
    ffi.Pointer<wasm_name_t> name,
    ffi.Pointer<wasm_externtype_t> arg2,
  ) {
    return _wasm_importtype_new(
      module,
      name,
      arg2,
    );
  }

  late final _wasm_importtype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_importtype_t> Function(
              ffi.Pointer<wasm_name_t>,
              ffi.Pointer<wasm_name_t>,
              ffi.Pointer<wasm_externtype_t>)>>('wasm_importtype_new');
  late final _wasm_importtype_new = _wasm_importtype_newPtr.asFunction<
      ffi.Pointer<wasm_importtype_t> Function(ffi.Pointer<wasm_name_t>,
          ffi.Pointer<wasm_name_t>, ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_name_t> wasm_importtype_module(
    ffi.Pointer<wasm_importtype_t> arg0,
  ) {
    return _wasm_importtype_module(
      arg0,
    );
  }

  late final _wasm_importtype_modulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_name_t> Function(
              ffi.Pointer<wasm_importtype_t>)>>('wasm_importtype_module');
  late final _wasm_importtype_module = _wasm_importtype_modulePtr.asFunction<
      ffi.Pointer<wasm_name_t> Function(ffi.Pointer<wasm_importtype_t>)>();

  ffi.Pointer<wasm_name_t> wasm_importtype_name(
    ffi.Pointer<wasm_importtype_t> arg0,
  ) {
    return _wasm_importtype_name(
      arg0,
    );
  }

  late final _wasm_importtype_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_name_t> Function(
              ffi.Pointer<wasm_importtype_t>)>>('wasm_importtype_name');
  late final _wasm_importtype_name = _wasm_importtype_namePtr.asFunction<
      ffi.Pointer<wasm_name_t> Function(ffi.Pointer<wasm_importtype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_importtype_type(
    ffi.Pointer<wasm_importtype_t> arg0,
  ) {
    return _wasm_importtype_type(
      arg0,
    );
  }

  late final _wasm_importtype_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_importtype_t>)>>('wasm_importtype_type');
  late final _wasm_importtype_type = _wasm_importtype_typePtr.asFunction<
      ffi.Pointer<wasm_externtype_t> Function(
          ffi.Pointer<wasm_importtype_t>)>();

  void wasm_exporttype_delete(
    ffi.Pointer<wasm_exporttype_t> arg0,
  ) {
    return _wasm_exporttype_delete(
      arg0,
    );
  }

  late final _wasm_exporttype_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_exporttype_t>)>>(
      'wasm_exporttype_delete');
  late final _wasm_exporttype_delete = _wasm_exporttype_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_exporttype_t>)>();

  void wasm_exporttype_vec_new_empty(
    ffi.Pointer<wasm_exporttype_vec_t> out,
  ) {
    return _wasm_exporttype_vec_new_empty(
      out,
    );
  }

  late final _wasm_exporttype_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_exporttype_vec_t>)>>(
      'wasm_exporttype_vec_new_empty');
  late final _wasm_exporttype_vec_new_empty = _wasm_exporttype_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_exporttype_vec_t>)>();

  void wasm_exporttype_vec_new_uninitialized(
    ffi.Pointer<wasm_exporttype_vec_t> out,
    int arg1,
  ) {
    return _wasm_exporttype_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_exporttype_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_exporttype_vec_t>,
              ffi.Size)>>('wasm_exporttype_vec_new_uninitialized');
  late final _wasm_exporttype_vec_new_uninitialized =
      _wasm_exporttype_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_exporttype_vec_t>, int)>();

  void wasm_exporttype_vec_new(
    ffi.Pointer<wasm_exporttype_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_exporttype_t>> arg2,
  ) {
    return _wasm_exporttype_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_exporttype_vec_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_exporttype_vec_t>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_exporttype_t>>)>>(
      'wasm_exporttype_vec_new');
  late final _wasm_exporttype_vec_new = _wasm_exporttype_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_exporttype_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_exporttype_t>>)>();

  void wasm_exporttype_vec_copy(
    ffi.Pointer<wasm_exporttype_vec_t> out,
    ffi.Pointer<wasm_exporttype_vec_t> arg1,
  ) {
    return _wasm_exporttype_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_exporttype_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_exporttype_vec_t>,
              ffi.Pointer<wasm_exporttype_vec_t>)>>('wasm_exporttype_vec_copy');
  late final _wasm_exporttype_vec_copy =
      _wasm_exporttype_vec_copyPtr.asFunction<
          void Function(ffi.Pointer<wasm_exporttype_vec_t>,
              ffi.Pointer<wasm_exporttype_vec_t>)>();

  void wasm_exporttype_vec_delete(
    ffi.Pointer<wasm_exporttype_vec_t> arg0,
  ) {
    return _wasm_exporttype_vec_delete(
      arg0,
    );
  }

  late final _wasm_exporttype_vec_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_exporttype_vec_t>)>>(
      'wasm_exporttype_vec_delete');
  late final _wasm_exporttype_vec_delete = _wasm_exporttype_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_exporttype_vec_t>)>();

  ffi.Pointer<wasm_exporttype_t> wasm_exporttype_copy(
    ffi.Pointer<wasm_exporttype_t> arg0,
  ) {
    return _wasm_exporttype_copy(
      arg0,
    );
  }

  late final _wasm_exporttype_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_exporttype_t> Function(
              ffi.Pointer<wasm_exporttype_t>)>>('wasm_exporttype_copy');
  late final _wasm_exporttype_copy = _wasm_exporttype_copyPtr.asFunction<
      ffi.Pointer<wasm_exporttype_t> Function(
          ffi.Pointer<wasm_exporttype_t>)>();

  ffi.Pointer<wasm_exporttype_t> wasm_exporttype_new(
    ffi.Pointer<wasm_name_t> arg0,
    ffi.Pointer<wasm_externtype_t> arg1,
  ) {
    return _wasm_exporttype_new(
      arg0,
      arg1,
    );
  }

  late final _wasm_exporttype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_exporttype_t> Function(ffi.Pointer<wasm_name_t>,
              ffi.Pointer<wasm_externtype_t>)>>('wasm_exporttype_new');
  late final _wasm_exporttype_new = _wasm_exporttype_newPtr.asFunction<
      ffi.Pointer<wasm_exporttype_t> Function(
          ffi.Pointer<wasm_name_t>, ffi.Pointer<wasm_externtype_t>)>();

  ffi.Pointer<wasm_name_t> wasm_exporttype_name(
    ffi.Pointer<wasm_exporttype_t> arg0,
  ) {
    return _wasm_exporttype_name(
      arg0,
    );
  }

  late final _wasm_exporttype_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_name_t> Function(
              ffi.Pointer<wasm_exporttype_t>)>>('wasm_exporttype_name');
  late final _wasm_exporttype_name = _wasm_exporttype_namePtr.asFunction<
      ffi.Pointer<wasm_name_t> Function(ffi.Pointer<wasm_exporttype_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_exporttype_type(
    ffi.Pointer<wasm_exporttype_t> arg0,
  ) {
    return _wasm_exporttype_type(
      arg0,
    );
  }

  late final _wasm_exporttype_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_exporttype_t>)>>('wasm_exporttype_type');
  late final _wasm_exporttype_type = _wasm_exporttype_typePtr.asFunction<
      ffi.Pointer<wasm_externtype_t> Function(
          ffi.Pointer<wasm_exporttype_t>)>();

  void wasm_val_delete(
    ffi.Pointer<wasm_val_t> v,
  ) {
    return _wasm_val_delete(
      v,
    );
  }

  late final _wasm_val_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_val_t>)>>(
          'wasm_val_delete');
  late final _wasm_val_delete =
      _wasm_val_deletePtr.asFunction<void Function(ffi.Pointer<wasm_val_t>)>();

  void wasm_val_copy(
    ffi.Pointer<wasm_val_t> out,
    ffi.Pointer<wasm_val_t> arg1,
  ) {
    return _wasm_val_copy(
      out,
      arg1,
    );
  }

  late final _wasm_val_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_val_t>,
              ffi.Pointer<wasm_val_t>)>>('wasm_val_copy');
  late final _wasm_val_copy = _wasm_val_copyPtr.asFunction<
      void Function(ffi.Pointer<wasm_val_t>, ffi.Pointer<wasm_val_t>)>();

  void wasm_val_vec_new_empty(
    ffi.Pointer<wasm_val_vec_t> out,
  ) {
    return _wasm_val_vec_new_empty(
      out,
    );
  }

  late final _wasm_val_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_val_vec_t>)>>(
      'wasm_val_vec_new_empty');
  late final _wasm_val_vec_new_empty = _wasm_val_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_val_vec_t>)>();

  void wasm_val_vec_new_uninitialized(
    ffi.Pointer<wasm_val_vec_t> out,
    int arg1,
  ) {
    return _wasm_val_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_val_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_val_vec_t>,
              ffi.Size)>>('wasm_val_vec_new_uninitialized');
  late final _wasm_val_vec_new_uninitialized =
      _wasm_val_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_val_vec_t>, int)>();

  void wasm_val_vec_new(
    ffi.Pointer<wasm_val_vec_t> out,
    int arg1,
    ffi.Pointer<wasm_val_t> arg2,
  ) {
    return _wasm_val_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_val_vec_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_val_vec_t>, ffi.Size,
              ffi.Pointer<wasm_val_t>)>>('wasm_val_vec_new');
  late final _wasm_val_vec_new = _wasm_val_vec_newPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_val_vec_t>, int, ffi.Pointer<wasm_val_t>)>();

  void wasm_val_vec_copy(
    ffi.Pointer<wasm_val_vec_t> out,
    ffi.Pointer<wasm_val_vec_t> arg1,
  ) {
    return _wasm_val_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_val_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_val_vec_t>,
              ffi.Pointer<wasm_val_vec_t>)>>('wasm_val_vec_copy');
  late final _wasm_val_vec_copy = _wasm_val_vec_copyPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_val_vec_t>, ffi.Pointer<wasm_val_vec_t>)>();

  void wasm_val_vec_delete(
    ffi.Pointer<wasm_val_vec_t> arg0,
  ) {
    return _wasm_val_vec_delete(
      arg0,
    );
  }

  late final _wasm_val_vec_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_val_vec_t>)>>(
      'wasm_val_vec_delete');
  late final _wasm_val_vec_delete = _wasm_val_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_val_vec_t>)>();

  void wasm_ref_delete(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_delete(
      arg0,
    );
  }

  late final _wasm_ref_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_ref_t>)>>(
          'wasm_ref_delete');
  late final _wasm_ref_delete =
      _wasm_ref_deletePtr.asFunction<void Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_ref_copy(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_copy(
      arg0,
    );
  }

  late final _wasm_ref_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_copy');
  late final _wasm_ref_copy = _wasm_ref_copyPtr
      .asFunction<ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_ref_t>)>();

  bool wasm_ref_same(
    ffi.Pointer<wasm_ref_t> arg0,
    ffi.Pointer<wasm_ref_t> arg1,
  ) {
    return _wasm_ref_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_ref_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_ref_t>,
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_same');
  late final _wasm_ref_same = _wasm_ref_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_ref_t>, ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<ffi.Void> wasm_ref_get_host_info(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_get_host_info(
      arg0,
    );
  }

  late final _wasm_ref_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_get_host_info');
  late final _wasm_ref_get_host_info = _wasm_ref_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_ref_t>)>();

  void wasm_ref_set_host_info(
    ffi.Pointer<wasm_ref_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_ref_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_ref_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_ref_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_ref_set_host_info');
  late final _wasm_ref_set_host_info = _wasm_ref_set_host_infoPtr.asFunction<
      void Function(ffi.Pointer<wasm_ref_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_ref_set_host_info_with_finalizer(
    ffi.Pointer<wasm_ref_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_ref_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_ref_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_ref_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_ref_set_host_info_with_finalizer');
  late final _wasm_ref_set_host_info_with_finalizer =
      _wasm_ref_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_ref_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  void wasm_frame_delete(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasm_frame_delete(
      arg0,
    );
  }

  late final _wasm_frame_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_frame_t>)>>(
          'wasm_frame_delete');
  late final _wasm_frame_delete = _wasm_frame_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_frame_t>)>();

  void wasm_frame_vec_new_empty(
    ffi.Pointer<wasm_frame_vec_t> out,
  ) {
    return _wasm_frame_vec_new_empty(
      out,
    );
  }

  late final _wasm_frame_vec_new_emptyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_frame_vec_t>)>>(
      'wasm_frame_vec_new_empty');
  late final _wasm_frame_vec_new_empty = _wasm_frame_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_frame_vec_t>)>();

  void wasm_frame_vec_new_uninitialized(
    ffi.Pointer<wasm_frame_vec_t> out,
    int arg1,
  ) {
    return _wasm_frame_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_frame_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_frame_vec_t>,
              ffi.Size)>>('wasm_frame_vec_new_uninitialized');
  late final _wasm_frame_vec_new_uninitialized =
      _wasm_frame_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_frame_vec_t>, int)>();

  void wasm_frame_vec_new(
    ffi.Pointer<wasm_frame_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_frame_t>> arg2,
  ) {
    return _wasm_frame_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_frame_vec_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_frame_vec_t>, ffi.Size,
              ffi.Pointer<ffi.Pointer<wasm_frame_t>>)>>('wasm_frame_vec_new');
  late final _wasm_frame_vec_new = _wasm_frame_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_frame_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_frame_t>>)>();

  void wasm_frame_vec_copy(
    ffi.Pointer<wasm_frame_vec_t> out,
    ffi.Pointer<wasm_frame_vec_t> arg1,
  ) {
    return _wasm_frame_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_frame_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_frame_vec_t>,
              ffi.Pointer<wasm_frame_vec_t>)>>('wasm_frame_vec_copy');
  late final _wasm_frame_vec_copy = _wasm_frame_vec_copyPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_frame_vec_t>, ffi.Pointer<wasm_frame_vec_t>)>();

  void wasm_frame_vec_delete(
    ffi.Pointer<wasm_frame_vec_t> arg0,
  ) {
    return _wasm_frame_vec_delete(
      arg0,
    );
  }

  late final _wasm_frame_vec_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_frame_vec_t>)>>(
      'wasm_frame_vec_delete');
  late final _wasm_frame_vec_delete = _wasm_frame_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_frame_vec_t>)>();

  ffi.Pointer<wasm_frame_t> wasm_frame_copy(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasm_frame_copy(
      arg0,
    );
  }

  late final _wasm_frame_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_frame_t> Function(
              ffi.Pointer<wasm_frame_t>)>>('wasm_frame_copy');
  late final _wasm_frame_copy = _wasm_frame_copyPtr.asFunction<
      ffi.Pointer<wasm_frame_t> Function(ffi.Pointer<wasm_frame_t>)>();

  ffi.Pointer<wasm_instance_t> wasm_frame_instance(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasm_frame_instance(
      arg0,
    );
  }

  late final _wasm_frame_instancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_instance_t> Function(
              ffi.Pointer<wasm_frame_t>)>>('wasm_frame_instance');
  late final _wasm_frame_instance = _wasm_frame_instancePtr.asFunction<
      ffi.Pointer<wasm_instance_t> Function(ffi.Pointer<wasm_frame_t>)>();

  int wasm_frame_func_index(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasm_frame_func_index(
      arg0,
    );
  }

  late final _wasm_frame_func_indexPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<wasm_frame_t>)>>(
      'wasm_frame_func_index');
  late final _wasm_frame_func_index = _wasm_frame_func_indexPtr
      .asFunction<int Function(ffi.Pointer<wasm_frame_t>)>();

  int wasm_frame_func_offset(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasm_frame_func_offset(
      arg0,
    );
  }

  late final _wasm_frame_func_offsetPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<wasm_frame_t>)>>(
          'wasm_frame_func_offset');
  late final _wasm_frame_func_offset = _wasm_frame_func_offsetPtr
      .asFunction<int Function(ffi.Pointer<wasm_frame_t>)>();

  int wasm_frame_module_offset(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasm_frame_module_offset(
      arg0,
    );
  }

  late final _wasm_frame_module_offsetPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<wasm_frame_t>)>>(
          'wasm_frame_module_offset');
  late final _wasm_frame_module_offset = _wasm_frame_module_offsetPtr
      .asFunction<int Function(ffi.Pointer<wasm_frame_t>)>();

  void wasm_trap_delete(
    ffi.Pointer<wasm_trap_t> arg0,
  ) {
    return _wasm_trap_delete(
      arg0,
    );
  }

  late final _wasm_trap_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_trap_t>)>>(
          'wasm_trap_delete');
  late final _wasm_trap_delete = _wasm_trap_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_trap_t>)>();

  ffi.Pointer<wasm_trap_t> wasm_trap_copy(
    ffi.Pointer<wasm_trap_t> arg0,
  ) {
    return _wasm_trap_copy(
      arg0,
    );
  }

  late final _wasm_trap_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_trap_t> Function(
              ffi.Pointer<wasm_trap_t>)>>('wasm_trap_copy');
  late final _wasm_trap_copy = _wasm_trap_copyPtr.asFunction<
      ffi.Pointer<wasm_trap_t> Function(ffi.Pointer<wasm_trap_t>)>();

  bool wasm_trap_same(
    ffi.Pointer<wasm_trap_t> arg0,
    ffi.Pointer<wasm_trap_t> arg1,
  ) {
    return _wasm_trap_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_trap_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_trap_t>,
              ffi.Pointer<wasm_trap_t>)>>('wasm_trap_same');
  late final _wasm_trap_same = _wasm_trap_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_trap_t>, ffi.Pointer<wasm_trap_t>)>();

  ffi.Pointer<ffi.Void> wasm_trap_get_host_info(
    ffi.Pointer<wasm_trap_t> arg0,
  ) {
    return _wasm_trap_get_host_info(
      arg0,
    );
  }

  late final _wasm_trap_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_trap_t>)>>('wasm_trap_get_host_info');
  late final _wasm_trap_get_host_info = _wasm_trap_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_trap_t>)>();

  void wasm_trap_set_host_info(
    ffi.Pointer<wasm_trap_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_trap_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_trap_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_trap_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_trap_set_host_info');
  late final _wasm_trap_set_host_info = _wasm_trap_set_host_infoPtr.asFunction<
      void Function(ffi.Pointer<wasm_trap_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_trap_set_host_info_with_finalizer(
    ffi.Pointer<wasm_trap_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_trap_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_trap_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_trap_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_trap_set_host_info_with_finalizer');
  late final _wasm_trap_set_host_info_with_finalizer =
      _wasm_trap_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_trap_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_trap_as_ref(
    ffi.Pointer<wasm_trap_t> arg0,
  ) {
    return _wasm_trap_as_ref(
      arg0,
    );
  }

  late final _wasm_trap_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_trap_t>)>>('wasm_trap_as_ref');
  late final _wasm_trap_as_ref = _wasm_trap_as_refPtr
      .asFunction<ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_trap_t>)>();

  ffi.Pointer<wasm_trap_t> wasm_ref_as_trap(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_trap(
      arg0,
    );
  }

  late final _wasm_ref_as_trapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_trap_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_trap');
  late final _wasm_ref_as_trap = _wasm_ref_as_trapPtr
      .asFunction<ffi.Pointer<wasm_trap_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_trap_as_ref_const(
    ffi.Pointer<wasm_trap_t> arg0,
  ) {
    return _wasm_trap_as_ref_const(
      arg0,
    );
  }

  late final _wasm_trap_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_trap_t>)>>('wasm_trap_as_ref_const');
  late final _wasm_trap_as_ref_const = _wasm_trap_as_ref_constPtr
      .asFunction<ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_trap_t>)>();

  ffi.Pointer<wasm_trap_t> wasm_ref_as_trap_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_trap_const(
      arg0,
    );
  }

  late final _wasm_ref_as_trap_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_trap_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_trap_const');
  late final _wasm_ref_as_trap_const = _wasm_ref_as_trap_constPtr
      .asFunction<ffi.Pointer<wasm_trap_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_trap_t> wasm_trap_new(
    ffi.Pointer<wasm_store_t> store,
    ffi.Pointer<wasm_message_t> arg1,
  ) {
    return _wasm_trap_new(
      store,
      arg1,
    );
  }

  late final _wasm_trap_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_trap_t> Function(ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_message_t>)>>('wasm_trap_new');
  late final _wasm_trap_new = _wasm_trap_newPtr.asFunction<
      ffi.Pointer<wasm_trap_t> Function(
          ffi.Pointer<wasm_store_t>, ffi.Pointer<wasm_message_t>)>();

  void wasm_trap_message(
    ffi.Pointer<wasm_trap_t> arg0,
    ffi.Pointer<wasm_message_t> out,
  ) {
    return _wasm_trap_message(
      arg0,
      out,
    );
  }

  late final _wasm_trap_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_trap_t>,
              ffi.Pointer<wasm_message_t>)>>('wasm_trap_message');
  late final _wasm_trap_message = _wasm_trap_messagePtr.asFunction<
      void Function(ffi.Pointer<wasm_trap_t>, ffi.Pointer<wasm_message_t>)>();

  ffi.Pointer<wasm_frame_t> wasm_trap_origin(
    ffi.Pointer<wasm_trap_t> arg0,
  ) {
    return _wasm_trap_origin(
      arg0,
    );
  }

  late final _wasm_trap_originPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_frame_t> Function(
              ffi.Pointer<wasm_trap_t>)>>('wasm_trap_origin');
  late final _wasm_trap_origin = _wasm_trap_originPtr.asFunction<
      ffi.Pointer<wasm_frame_t> Function(ffi.Pointer<wasm_trap_t>)>();

  void wasm_trap_trace(
    ffi.Pointer<wasm_trap_t> arg0,
    ffi.Pointer<wasm_frame_vec_t> out,
  ) {
    return _wasm_trap_trace(
      arg0,
      out,
    );
  }

  late final _wasm_trap_tracePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_trap_t>,
              ffi.Pointer<wasm_frame_vec_t>)>>('wasm_trap_trace');
  late final _wasm_trap_trace = _wasm_trap_tracePtr.asFunction<
      void Function(ffi.Pointer<wasm_trap_t>, ffi.Pointer<wasm_frame_vec_t>)>();

  void wasm_foreign_delete(
    ffi.Pointer<wasm_foreign_t> arg0,
  ) {
    return _wasm_foreign_delete(
      arg0,
    );
  }

  late final _wasm_foreign_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_foreign_t>)>>(
      'wasm_foreign_delete');
  late final _wasm_foreign_delete = _wasm_foreign_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_foreign_t>)>();

  ffi.Pointer<wasm_foreign_t> wasm_foreign_copy(
    ffi.Pointer<wasm_foreign_t> arg0,
  ) {
    return _wasm_foreign_copy(
      arg0,
    );
  }

  late final _wasm_foreign_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_foreign_t> Function(
              ffi.Pointer<wasm_foreign_t>)>>('wasm_foreign_copy');
  late final _wasm_foreign_copy = _wasm_foreign_copyPtr.asFunction<
      ffi.Pointer<wasm_foreign_t> Function(ffi.Pointer<wasm_foreign_t>)>();

  bool wasm_foreign_same(
    ffi.Pointer<wasm_foreign_t> arg0,
    ffi.Pointer<wasm_foreign_t> arg1,
  ) {
    return _wasm_foreign_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_foreign_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_foreign_t>,
              ffi.Pointer<wasm_foreign_t>)>>('wasm_foreign_same');
  late final _wasm_foreign_same = _wasm_foreign_samePtr.asFunction<
      bool Function(
          ffi.Pointer<wasm_foreign_t>, ffi.Pointer<wasm_foreign_t>)>();

  ffi.Pointer<ffi.Void> wasm_foreign_get_host_info(
    ffi.Pointer<wasm_foreign_t> arg0,
  ) {
    return _wasm_foreign_get_host_info(
      arg0,
    );
  }

  late final _wasm_foreign_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_foreign_t>)>>('wasm_foreign_get_host_info');
  late final _wasm_foreign_get_host_info =
      _wasm_foreign_get_host_infoPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_foreign_t>)>();

  void wasm_foreign_set_host_info(
    ffi.Pointer<wasm_foreign_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_foreign_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_foreign_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_foreign_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_foreign_set_host_info');
  late final _wasm_foreign_set_host_info =
      _wasm_foreign_set_host_infoPtr.asFunction<
          void Function(ffi.Pointer<wasm_foreign_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_foreign_set_host_info_with_finalizer(
    ffi.Pointer<wasm_foreign_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_foreign_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_foreign_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_foreign_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_foreign_set_host_info_with_finalizer');
  late final _wasm_foreign_set_host_info_with_finalizer =
      _wasm_foreign_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_foreign_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_foreign_as_ref(
    ffi.Pointer<wasm_foreign_t> arg0,
  ) {
    return _wasm_foreign_as_ref(
      arg0,
    );
  }

  late final _wasm_foreign_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_foreign_t>)>>('wasm_foreign_as_ref');
  late final _wasm_foreign_as_ref = _wasm_foreign_as_refPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_foreign_t>)>();

  ffi.Pointer<wasm_foreign_t> wasm_ref_as_foreign(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_foreign(
      arg0,
    );
  }

  late final _wasm_ref_as_foreignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_foreign_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_foreign');
  late final _wasm_ref_as_foreign = _wasm_ref_as_foreignPtr.asFunction<
      ffi.Pointer<wasm_foreign_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_foreign_as_ref_const(
    ffi.Pointer<wasm_foreign_t> arg0,
  ) {
    return _wasm_foreign_as_ref_const(
      arg0,
    );
  }

  late final _wasm_foreign_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_foreign_t>)>>('wasm_foreign_as_ref_const');
  late final _wasm_foreign_as_ref_const =
      _wasm_foreign_as_ref_constPtr.asFunction<
          ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_foreign_t>)>();

  ffi.Pointer<wasm_foreign_t> wasm_ref_as_foreign_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_foreign_const(
      arg0,
    );
  }

  late final _wasm_ref_as_foreign_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_foreign_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_foreign_const');
  late final _wasm_ref_as_foreign_const =
      _wasm_ref_as_foreign_constPtr.asFunction<
          ffi.Pointer<wasm_foreign_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_foreign_t> wasm_foreign_new(
    ffi.Pointer<wasm_store_t> arg0,
  ) {
    return _wasm_foreign_new(
      arg0,
    );
  }

  late final _wasm_foreign_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_foreign_t> Function(
              ffi.Pointer<wasm_store_t>)>>('wasm_foreign_new');
  late final _wasm_foreign_new = _wasm_foreign_newPtr.asFunction<
      ffi.Pointer<wasm_foreign_t> Function(ffi.Pointer<wasm_store_t>)>();

  void wasm_module_delete(
    ffi.Pointer<wasm_module_t> arg0,
  ) {
    return _wasm_module_delete(
      arg0,
    );
  }

  late final _wasm_module_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_module_t>)>>(
      'wasm_module_delete');
  late final _wasm_module_delete = _wasm_module_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_module_t>)>();

  ffi.Pointer<wasm_module_t> wasm_module_copy(
    ffi.Pointer<wasm_module_t> arg0,
  ) {
    return _wasm_module_copy(
      arg0,
    );
  }

  late final _wasm_module_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_module_t> Function(
              ffi.Pointer<wasm_module_t>)>>('wasm_module_copy');
  late final _wasm_module_copy = _wasm_module_copyPtr.asFunction<
      ffi.Pointer<wasm_module_t> Function(ffi.Pointer<wasm_module_t>)>();

  bool wasm_module_same(
    ffi.Pointer<wasm_module_t> arg0,
    ffi.Pointer<wasm_module_t> arg1,
  ) {
    return _wasm_module_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_module_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_module_t>,
              ffi.Pointer<wasm_module_t>)>>('wasm_module_same');
  late final _wasm_module_same = _wasm_module_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_module_t>, ffi.Pointer<wasm_module_t>)>();

  ffi.Pointer<ffi.Void> wasm_module_get_host_info(
    ffi.Pointer<wasm_module_t> arg0,
  ) {
    return _wasm_module_get_host_info(
      arg0,
    );
  }

  late final _wasm_module_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_module_t>)>>('wasm_module_get_host_info');
  late final _wasm_module_get_host_info = _wasm_module_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_module_t>)>();

  void wasm_module_set_host_info(
    ffi.Pointer<wasm_module_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_module_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_module_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_module_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_module_set_host_info');
  late final _wasm_module_set_host_info =
      _wasm_module_set_host_infoPtr.asFunction<
          void Function(ffi.Pointer<wasm_module_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_module_set_host_info_with_finalizer(
    ffi.Pointer<wasm_module_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_module_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_module_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_module_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_module_set_host_info_with_finalizer');
  late final _wasm_module_set_host_info_with_finalizer =
      _wasm_module_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_module_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_module_as_ref(
    ffi.Pointer<wasm_module_t> arg0,
  ) {
    return _wasm_module_as_ref(
      arg0,
    );
  }

  late final _wasm_module_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_module_t>)>>('wasm_module_as_ref');
  late final _wasm_module_as_ref = _wasm_module_as_refPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_module_t>)>();

  ffi.Pointer<wasm_module_t> wasm_ref_as_module(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_module(
      arg0,
    );
  }

  late final _wasm_ref_as_modulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_module_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_module');
  late final _wasm_ref_as_module = _wasm_ref_as_modulePtr.asFunction<
      ffi.Pointer<wasm_module_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_module_as_ref_const(
    ffi.Pointer<wasm_module_t> arg0,
  ) {
    return _wasm_module_as_ref_const(
      arg0,
    );
  }

  late final _wasm_module_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_module_t>)>>('wasm_module_as_ref_const');
  late final _wasm_module_as_ref_const =
      _wasm_module_as_ref_constPtr.asFunction<
          ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_module_t>)>();

  ffi.Pointer<wasm_module_t> wasm_ref_as_module_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_module_const(
      arg0,
    );
  }

  late final _wasm_ref_as_module_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_module_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_module_const');
  late final _wasm_ref_as_module_const =
      _wasm_ref_as_module_constPtr.asFunction<
          ffi.Pointer<wasm_module_t> Function(ffi.Pointer<wasm_ref_t>)>();

  void wasm_shared_module_delete(
    ffi.Pointer<wasm_shared_module_t> arg0,
  ) {
    return _wasm_shared_module_delete(
      arg0,
    );
  }

  late final _wasm_shared_module_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasm_shared_module_t>)>>('wasm_shared_module_delete');
  late final _wasm_shared_module_delete = _wasm_shared_module_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_shared_module_t>)>();

  ffi.Pointer<wasm_shared_module_t> wasm_module_share(
    ffi.Pointer<wasm_module_t> arg0,
  ) {
    return _wasm_module_share(
      arg0,
    );
  }

  late final _wasm_module_sharePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_shared_module_t> Function(
              ffi.Pointer<wasm_module_t>)>>('wasm_module_share');
  late final _wasm_module_share = _wasm_module_sharePtr.asFunction<
      ffi.Pointer<wasm_shared_module_t> Function(ffi.Pointer<wasm_module_t>)>();

  ffi.Pointer<wasm_module_t> wasm_module_obtain(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_shared_module_t> arg1,
  ) {
    return _wasm_module_obtain(
      arg0,
      arg1,
    );
  }

  late final _wasm_module_obtainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_module_t> Function(ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_shared_module_t>)>>('wasm_module_obtain');
  late final _wasm_module_obtain = _wasm_module_obtainPtr.asFunction<
      ffi.Pointer<wasm_module_t> Function(
          ffi.Pointer<wasm_store_t>, ffi.Pointer<wasm_shared_module_t>)>();

  ffi.Pointer<wasm_module_t> wasm_module_new(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_byte_vec_t> binary,
  ) {
    return _wasm_module_new(
      arg0,
      binary,
    );
  }

  late final _wasm_module_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_module_t> Function(ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_byte_vec_t>)>>('wasm_module_new');
  late final _wasm_module_new = _wasm_module_newPtr.asFunction<
      ffi.Pointer<wasm_module_t> Function(
          ffi.Pointer<wasm_store_t>, ffi.Pointer<wasm_byte_vec_t>)>();

  bool wasm_module_validate(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_byte_vec_t> binary,
  ) {
    return _wasm_module_validate(
      arg0,
      binary,
    );
  }

  late final _wasm_module_validatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_byte_vec_t>)>>('wasm_module_validate');
  late final _wasm_module_validate = _wasm_module_validatePtr.asFunction<
      bool Function(ffi.Pointer<wasm_store_t>, ffi.Pointer<wasm_byte_vec_t>)>();

  void wasm_module_imports(
    ffi.Pointer<wasm_module_t> arg0,
    ffi.Pointer<wasm_importtype_vec_t> out,
  ) {
    return _wasm_module_imports(
      arg0,
      out,
    );
  }

  late final _wasm_module_importsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_module_t>,
              ffi.Pointer<wasm_importtype_vec_t>)>>('wasm_module_imports');
  late final _wasm_module_imports = _wasm_module_importsPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_module_t>, ffi.Pointer<wasm_importtype_vec_t>)>();

  void wasm_module_exports(
    ffi.Pointer<wasm_module_t> arg0,
    ffi.Pointer<wasm_exporttype_vec_t> out,
  ) {
    return _wasm_module_exports(
      arg0,
      out,
    );
  }

  late final _wasm_module_exportsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_module_t>,
              ffi.Pointer<wasm_exporttype_vec_t>)>>('wasm_module_exports');
  late final _wasm_module_exports = _wasm_module_exportsPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_module_t>, ffi.Pointer<wasm_exporttype_vec_t>)>();

  void wasm_module_serialize(
    ffi.Pointer<wasm_module_t> arg0,
    ffi.Pointer<wasm_byte_vec_t> out,
  ) {
    return _wasm_module_serialize(
      arg0,
      out,
    );
  }

  late final _wasm_module_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_module_t>,
              ffi.Pointer<wasm_byte_vec_t>)>>('wasm_module_serialize');
  late final _wasm_module_serialize = _wasm_module_serializePtr.asFunction<
      void Function(
          ffi.Pointer<wasm_module_t>, ffi.Pointer<wasm_byte_vec_t>)>();

  ffi.Pointer<wasm_module_t> wasm_module_deserialize(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_byte_vec_t> arg1,
  ) {
    return _wasm_module_deserialize(
      arg0,
      arg1,
    );
  }

  late final _wasm_module_deserializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_module_t> Function(ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_byte_vec_t>)>>('wasm_module_deserialize');
  late final _wasm_module_deserialize = _wasm_module_deserializePtr.asFunction<
      ffi.Pointer<wasm_module_t> Function(
          ffi.Pointer<wasm_store_t>, ffi.Pointer<wasm_byte_vec_t>)>();

  void wasm_func_delete(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_delete(
      arg0,
    );
  }

  late final _wasm_func_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_func_t>)>>(
          'wasm_func_delete');
  late final _wasm_func_delete = _wasm_func_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_func_t>)>();

  ffi.Pointer<wasm_func_t> wasm_func_copy(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_copy(
      arg0,
    );
  }

  late final _wasm_func_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_func_t> Function(
              ffi.Pointer<wasm_func_t>)>>('wasm_func_copy');
  late final _wasm_func_copy = _wasm_func_copyPtr.asFunction<
      ffi.Pointer<wasm_func_t> Function(ffi.Pointer<wasm_func_t>)>();

  bool wasm_func_same(
    ffi.Pointer<wasm_func_t> arg0,
    ffi.Pointer<wasm_func_t> arg1,
  ) {
    return _wasm_func_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_func_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_func_t>,
              ffi.Pointer<wasm_func_t>)>>('wasm_func_same');
  late final _wasm_func_same = _wasm_func_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_func_t>, ffi.Pointer<wasm_func_t>)>();

  ffi.Pointer<ffi.Void> wasm_func_get_host_info(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_get_host_info(
      arg0,
    );
  }

  late final _wasm_func_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_func_t>)>>('wasm_func_get_host_info');
  late final _wasm_func_get_host_info = _wasm_func_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_func_t>)>();

  void wasm_func_set_host_info(
    ffi.Pointer<wasm_func_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_func_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_func_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_func_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_func_set_host_info');
  late final _wasm_func_set_host_info = _wasm_func_set_host_infoPtr.asFunction<
      void Function(ffi.Pointer<wasm_func_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_func_set_host_info_with_finalizer(
    ffi.Pointer<wasm_func_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_func_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_func_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_func_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_func_set_host_info_with_finalizer');
  late final _wasm_func_set_host_info_with_finalizer =
      _wasm_func_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_func_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_func_as_ref(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_as_ref(
      arg0,
    );
  }

  late final _wasm_func_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_func_t>)>>('wasm_func_as_ref');
  late final _wasm_func_as_ref = _wasm_func_as_refPtr
      .asFunction<ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_func_t>)>();

  ffi.Pointer<wasm_func_t> wasm_ref_as_func(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_func(
      arg0,
    );
  }

  late final _wasm_ref_as_funcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_func_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_func');
  late final _wasm_ref_as_func = _wasm_ref_as_funcPtr
      .asFunction<ffi.Pointer<wasm_func_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_func_as_ref_const(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_as_ref_const(
      arg0,
    );
  }

  late final _wasm_func_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_func_t>)>>('wasm_func_as_ref_const');
  late final _wasm_func_as_ref_const = _wasm_func_as_ref_constPtr
      .asFunction<ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_func_t>)>();

  ffi.Pointer<wasm_func_t> wasm_ref_as_func_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_func_const(
      arg0,
    );
  }

  late final _wasm_ref_as_func_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_func_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_func_const');
  late final _wasm_ref_as_func_const = _wasm_ref_as_func_constPtr
      .asFunction<ffi.Pointer<wasm_func_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_func_t> wasm_func_new(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_functype_t> arg1,
    wasm_func_callback_t arg2,
  ) {
    return _wasm_func_new(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_func_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_func_t> Function(
              ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_functype_t>,
              wasm_func_callback_t)>>('wasm_func_new');
  late final _wasm_func_new = _wasm_func_newPtr.asFunction<
      ffi.Pointer<wasm_func_t> Function(ffi.Pointer<wasm_store_t>,
          ffi.Pointer<wasm_functype_t>, wasm_func_callback_t)>();

  ffi.Pointer<wasm_func_t> wasm_func_new_with_env(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_functype_t> type,
    wasm_func_callback_with_env_t arg2,
    ffi.Pointer<ffi.Void> env,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        finalizer,
  ) {
    return _wasm_func_new_with_env(
      arg0,
      type,
      arg2,
      env,
      finalizer,
    );
  }

  late final _wasm_func_new_with_envPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_func_t> Function(
              ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_functype_t>,
              wasm_func_callback_with_env_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>)>>)>>('wasm_func_new_with_env');
  late final _wasm_func_new_with_env = _wasm_func_new_with_envPtr.asFunction<
      ffi.Pointer<wasm_func_t> Function(
          ffi.Pointer<wasm_store_t>,
          ffi.Pointer<wasm_functype_t>,
          wasm_func_callback_with_env_t,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_functype_t> wasm_func_type(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_type(
      arg0,
    );
  }

  late final _wasm_func_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_functype_t> Function(
              ffi.Pointer<wasm_func_t>)>>('wasm_func_type');
  late final _wasm_func_type = _wasm_func_typePtr.asFunction<
      ffi.Pointer<wasm_functype_t> Function(ffi.Pointer<wasm_func_t>)>();

  int wasm_func_param_arity(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_param_arity(
      arg0,
    );
  }

  late final _wasm_func_param_arityPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<wasm_func_t>)>>(
          'wasm_func_param_arity');
  late final _wasm_func_param_arity = _wasm_func_param_arityPtr
      .asFunction<int Function(ffi.Pointer<wasm_func_t>)>();

  int wasm_func_result_arity(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_result_arity(
      arg0,
    );
  }

  late final _wasm_func_result_arityPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<wasm_func_t>)>>(
          'wasm_func_result_arity');
  late final _wasm_func_result_arity = _wasm_func_result_arityPtr
      .asFunction<int Function(ffi.Pointer<wasm_func_t>)>();

  ffi.Pointer<wasm_trap_t> wasm_func_call(
    ffi.Pointer<wasm_func_t> arg0,
    ffi.Pointer<wasm_val_vec_t> args,
    ffi.Pointer<wasm_val_vec_t> results,
  ) {
    return _wasm_func_call(
      arg0,
      args,
      results,
    );
  }

  late final _wasm_func_callPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_trap_t> Function(
              ffi.Pointer<wasm_func_t>,
              ffi.Pointer<wasm_val_vec_t>,
              ffi.Pointer<wasm_val_vec_t>)>>('wasm_func_call');
  late final _wasm_func_call = _wasm_func_callPtr.asFunction<
      ffi.Pointer<wasm_trap_t> Function(ffi.Pointer<wasm_func_t>,
          ffi.Pointer<wasm_val_vec_t>, ffi.Pointer<wasm_val_vec_t>)>();

  void wasm_global_delete(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_delete(
      arg0,
    );
  }

  late final _wasm_global_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_global_t>)>>(
      'wasm_global_delete');
  late final _wasm_global_delete = _wasm_global_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_global_t>)>();

  ffi.Pointer<wasm_global_t> wasm_global_copy(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_copy(
      arg0,
    );
  }

  late final _wasm_global_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_global_t> Function(
              ffi.Pointer<wasm_global_t>)>>('wasm_global_copy');
  late final _wasm_global_copy = _wasm_global_copyPtr.asFunction<
      ffi.Pointer<wasm_global_t> Function(ffi.Pointer<wasm_global_t>)>();

  bool wasm_global_same(
    ffi.Pointer<wasm_global_t> arg0,
    ffi.Pointer<wasm_global_t> arg1,
  ) {
    return _wasm_global_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_global_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_global_t>,
              ffi.Pointer<wasm_global_t>)>>('wasm_global_same');
  late final _wasm_global_same = _wasm_global_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_global_t>, ffi.Pointer<wasm_global_t>)>();

  ffi.Pointer<ffi.Void> wasm_global_get_host_info(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_get_host_info(
      arg0,
    );
  }

  late final _wasm_global_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_global_t>)>>('wasm_global_get_host_info');
  late final _wasm_global_get_host_info = _wasm_global_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_global_t>)>();

  void wasm_global_set_host_info(
    ffi.Pointer<wasm_global_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_global_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_global_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_global_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_global_set_host_info');
  late final _wasm_global_set_host_info =
      _wasm_global_set_host_infoPtr.asFunction<
          void Function(ffi.Pointer<wasm_global_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_global_set_host_info_with_finalizer(
    ffi.Pointer<wasm_global_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_global_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_global_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_global_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_global_set_host_info_with_finalizer');
  late final _wasm_global_set_host_info_with_finalizer =
      _wasm_global_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_global_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_global_as_ref(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_as_ref(
      arg0,
    );
  }

  late final _wasm_global_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_global_t>)>>('wasm_global_as_ref');
  late final _wasm_global_as_ref = _wasm_global_as_refPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_global_t>)>();

  ffi.Pointer<wasm_global_t> wasm_ref_as_global(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_global(
      arg0,
    );
  }

  late final _wasm_ref_as_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_global_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_global');
  late final _wasm_ref_as_global = _wasm_ref_as_globalPtr.asFunction<
      ffi.Pointer<wasm_global_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_global_as_ref_const(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_as_ref_const(
      arg0,
    );
  }

  late final _wasm_global_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_global_t>)>>('wasm_global_as_ref_const');
  late final _wasm_global_as_ref_const =
      _wasm_global_as_ref_constPtr.asFunction<
          ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_global_t>)>();

  ffi.Pointer<wasm_global_t> wasm_ref_as_global_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_global_const(
      arg0,
    );
  }

  late final _wasm_ref_as_global_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_global_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_global_const');
  late final _wasm_ref_as_global_const =
      _wasm_ref_as_global_constPtr.asFunction<
          ffi.Pointer<wasm_global_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_global_t> wasm_global_new(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_globaltype_t> arg1,
    ffi.Pointer<wasm_val_t> arg2,
  ) {
    return _wasm_global_new(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_global_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_global_t> Function(
              ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_globaltype_t>,
              ffi.Pointer<wasm_val_t>)>>('wasm_global_new');
  late final _wasm_global_new = _wasm_global_newPtr.asFunction<
      ffi.Pointer<wasm_global_t> Function(ffi.Pointer<wasm_store_t>,
          ffi.Pointer<wasm_globaltype_t>, ffi.Pointer<wasm_val_t>)>();

  ffi.Pointer<wasm_globaltype_t> wasm_global_type(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_type(
      arg0,
    );
  }

  late final _wasm_global_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_globaltype_t> Function(
              ffi.Pointer<wasm_global_t>)>>('wasm_global_type');
  late final _wasm_global_type = _wasm_global_typePtr.asFunction<
      ffi.Pointer<wasm_globaltype_t> Function(ffi.Pointer<wasm_global_t>)>();

  void wasm_global_get(
    ffi.Pointer<wasm_global_t> arg0,
    ffi.Pointer<wasm_val_t> out,
  ) {
    return _wasm_global_get(
      arg0,
      out,
    );
  }

  late final _wasm_global_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_global_t>,
              ffi.Pointer<wasm_val_t>)>>('wasm_global_get');
  late final _wasm_global_get = _wasm_global_getPtr.asFunction<
      void Function(ffi.Pointer<wasm_global_t>, ffi.Pointer<wasm_val_t>)>();

  void wasm_global_set(
    ffi.Pointer<wasm_global_t> arg0,
    ffi.Pointer<wasm_val_t> arg1,
  ) {
    return _wasm_global_set(
      arg0,
      arg1,
    );
  }

  late final _wasm_global_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_global_t>,
              ffi.Pointer<wasm_val_t>)>>('wasm_global_set');
  late final _wasm_global_set = _wasm_global_setPtr.asFunction<
      void Function(ffi.Pointer<wasm_global_t>, ffi.Pointer<wasm_val_t>)>();

  void wasm_table_delete(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_delete(
      arg0,
    );
  }

  late final _wasm_table_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_table_t>)>>(
          'wasm_table_delete');
  late final _wasm_table_delete = _wasm_table_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_table_t>)>();

  ffi.Pointer<wasm_table_t> wasm_table_copy(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_copy(
      arg0,
    );
  }

  late final _wasm_table_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_table_t> Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_copy');
  late final _wasm_table_copy = _wasm_table_copyPtr.asFunction<
      ffi.Pointer<wasm_table_t> Function(ffi.Pointer<wasm_table_t>)>();

  bool wasm_table_same(
    ffi.Pointer<wasm_table_t> arg0,
    ffi.Pointer<wasm_table_t> arg1,
  ) {
    return _wasm_table_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_table_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_table_t>,
              ffi.Pointer<wasm_table_t>)>>('wasm_table_same');
  late final _wasm_table_same = _wasm_table_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_table_t>, ffi.Pointer<wasm_table_t>)>();

  ffi.Pointer<ffi.Void> wasm_table_get_host_info(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_get_host_info(
      arg0,
    );
  }

  late final _wasm_table_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_get_host_info');
  late final _wasm_table_get_host_info = _wasm_table_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_table_t>)>();

  void wasm_table_set_host_info(
    ffi.Pointer<wasm_table_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_table_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_table_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_table_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_table_set_host_info');
  late final _wasm_table_set_host_info =
      _wasm_table_set_host_infoPtr.asFunction<
          void Function(ffi.Pointer<wasm_table_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_table_set_host_info_with_finalizer(
    ffi.Pointer<wasm_table_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_table_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_table_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_table_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_table_set_host_info_with_finalizer');
  late final _wasm_table_set_host_info_with_finalizer =
      _wasm_table_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_table_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_table_as_ref(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_as_ref(
      arg0,
    );
  }

  late final _wasm_table_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_as_ref');
  late final _wasm_table_as_ref = _wasm_table_as_refPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_table_t>)>();

  ffi.Pointer<wasm_table_t> wasm_ref_as_table(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_table(
      arg0,
    );
  }

  late final _wasm_ref_as_tablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_table_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_table');
  late final _wasm_ref_as_table = _wasm_ref_as_tablePtr.asFunction<
      ffi.Pointer<wasm_table_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_table_as_ref_const(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_as_ref_const(
      arg0,
    );
  }

  late final _wasm_table_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_as_ref_const');
  late final _wasm_table_as_ref_const = _wasm_table_as_ref_constPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_table_t>)>();

  ffi.Pointer<wasm_table_t> wasm_ref_as_table_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_table_const(
      arg0,
    );
  }

  late final _wasm_ref_as_table_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_table_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_table_const');
  late final _wasm_ref_as_table_const = _wasm_ref_as_table_constPtr.asFunction<
      ffi.Pointer<wasm_table_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_table_t> wasm_table_new(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_tabletype_t> arg1,
    ffi.Pointer<wasm_ref_t> init,
  ) {
    return _wasm_table_new(
      arg0,
      arg1,
      init,
    );
  }

  late final _wasm_table_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_table_t> Function(
              ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_tabletype_t>,
              ffi.Pointer<wasm_ref_t>)>>('wasm_table_new');
  late final _wasm_table_new = _wasm_table_newPtr.asFunction<
      ffi.Pointer<wasm_table_t> Function(ffi.Pointer<wasm_store_t>,
          ffi.Pointer<wasm_tabletype_t>, ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_tabletype_t> wasm_table_type(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_type(
      arg0,
    );
  }

  late final _wasm_table_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_tabletype_t> Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_type');
  late final _wasm_table_type = _wasm_table_typePtr.asFunction<
      ffi.Pointer<wasm_tabletype_t> Function(ffi.Pointer<wasm_table_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_table_get(
    ffi.Pointer<wasm_table_t> arg0,
    int index,
  ) {
    return _wasm_table_get(
      arg0,
      index,
    );
  }

  late final _wasm_table_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_table_t>, wasm_table_size_t)>>('wasm_table_get');
  late final _wasm_table_get = _wasm_table_getPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_table_t>, int)>();

  bool wasm_table_set(
    ffi.Pointer<wasm_table_t> arg0,
    int index,
    ffi.Pointer<wasm_ref_t> arg2,
  ) {
    return _wasm_table_set(
      arg0,
      index,
      arg2,
    );
  }

  late final _wasm_table_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_table_t>, wasm_table_size_t,
              ffi.Pointer<wasm_ref_t>)>>('wasm_table_set');
  late final _wasm_table_set = _wasm_table_setPtr.asFunction<
      bool Function(ffi.Pointer<wasm_table_t>, int, ffi.Pointer<wasm_ref_t>)>();

  int wasm_table_size(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_size(
      arg0,
    );
  }

  late final _wasm_table_sizePtr = _lookup<
      ffi.NativeFunction<
          wasm_table_size_t Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_size');
  late final _wasm_table_size =
      _wasm_table_sizePtr.asFunction<int Function(ffi.Pointer<wasm_table_t>)>();

  bool wasm_table_grow(
    ffi.Pointer<wasm_table_t> arg0,
    int delta,
    ffi.Pointer<wasm_ref_t> init,
  ) {
    return _wasm_table_grow(
      arg0,
      delta,
      init,
    );
  }

  late final _wasm_table_growPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_table_t>, wasm_table_size_t,
              ffi.Pointer<wasm_ref_t>)>>('wasm_table_grow');
  late final _wasm_table_grow = _wasm_table_growPtr.asFunction<
      bool Function(ffi.Pointer<wasm_table_t>, int, ffi.Pointer<wasm_ref_t>)>();

  void wasm_memory_delete(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_delete(
      arg0,
    );
  }

  late final _wasm_memory_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_memory_t>)>>(
      'wasm_memory_delete');
  late final _wasm_memory_delete = _wasm_memory_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_memory_t>)>();

  ffi.Pointer<wasm_memory_t> wasm_memory_copy(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_copy(
      arg0,
    );
  }

  late final _wasm_memory_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memory_t> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_copy');
  late final _wasm_memory_copy = _wasm_memory_copyPtr.asFunction<
      ffi.Pointer<wasm_memory_t> Function(ffi.Pointer<wasm_memory_t>)>();

  bool wasm_memory_same(
    ffi.Pointer<wasm_memory_t> arg0,
    ffi.Pointer<wasm_memory_t> arg1,
  ) {
    return _wasm_memory_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_memory_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_memory_t>,
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_same');
  late final _wasm_memory_same = _wasm_memory_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_memory_t>, ffi.Pointer<wasm_memory_t>)>();

  ffi.Pointer<ffi.Void> wasm_memory_get_host_info(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_get_host_info(
      arg0,
    );
  }

  late final _wasm_memory_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_get_host_info');
  late final _wasm_memory_get_host_info = _wasm_memory_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_memory_t>)>();

  void wasm_memory_set_host_info(
    ffi.Pointer<wasm_memory_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_memory_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_memory_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_memory_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_memory_set_host_info');
  late final _wasm_memory_set_host_info =
      _wasm_memory_set_host_infoPtr.asFunction<
          void Function(ffi.Pointer<wasm_memory_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_memory_set_host_info_with_finalizer(
    ffi.Pointer<wasm_memory_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_memory_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_memory_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_memory_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_memory_set_host_info_with_finalizer');
  late final _wasm_memory_set_host_info_with_finalizer =
      _wasm_memory_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_memory_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_memory_as_ref(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_as_ref(
      arg0,
    );
  }

  late final _wasm_memory_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_as_ref');
  late final _wasm_memory_as_ref = _wasm_memory_as_refPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_memory_t>)>();

  ffi.Pointer<wasm_memory_t> wasm_ref_as_memory(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_memory(
      arg0,
    );
  }

  late final _wasm_ref_as_memoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memory_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_memory');
  late final _wasm_ref_as_memory = _wasm_ref_as_memoryPtr.asFunction<
      ffi.Pointer<wasm_memory_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_memory_as_ref_const(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_as_ref_const(
      arg0,
    );
  }

  late final _wasm_memory_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_as_ref_const');
  late final _wasm_memory_as_ref_const =
      _wasm_memory_as_ref_constPtr.asFunction<
          ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_memory_t>)>();

  ffi.Pointer<wasm_memory_t> wasm_ref_as_memory_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_memory_const(
      arg0,
    );
  }

  late final _wasm_ref_as_memory_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memory_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_memory_const');
  late final _wasm_ref_as_memory_const =
      _wasm_ref_as_memory_constPtr.asFunction<
          ffi.Pointer<wasm_memory_t> Function(ffi.Pointer<wasm_ref_t>)>();

  late final ffi.Pointer<ffi.Size> _MEMORY_PAGE_SIZE =
      _lookup<ffi.Size>('MEMORY_PAGE_SIZE');

  int get MEMORY_PAGE_SIZE => _MEMORY_PAGE_SIZE.value;

  set MEMORY_PAGE_SIZE(int value) => _MEMORY_PAGE_SIZE.value = value;

  ffi.Pointer<wasm_memory_t> wasm_memory_new(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_memorytype_t> arg1,
  ) {
    return _wasm_memory_new(
      arg0,
      arg1,
    );
  }

  late final _wasm_memory_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memory_t> Function(ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_memorytype_t>)>>('wasm_memory_new');
  late final _wasm_memory_new = _wasm_memory_newPtr.asFunction<
      ffi.Pointer<wasm_memory_t> Function(
          ffi.Pointer<wasm_store_t>, ffi.Pointer<wasm_memorytype_t>)>();

  ffi.Pointer<wasm_memorytype_t> wasm_memory_type(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_type(
      arg0,
    );
  }

  late final _wasm_memory_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memorytype_t> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_type');
  late final _wasm_memory_type = _wasm_memory_typePtr.asFunction<
      ffi.Pointer<wasm_memorytype_t> Function(ffi.Pointer<wasm_memory_t>)>();

  ffi.Pointer<byte_t> wasm_memory_data(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_data(
      arg0,
    );
  }

  late final _wasm_memory_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<byte_t> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_data');
  late final _wasm_memory_data = _wasm_memory_dataPtr
      .asFunction<ffi.Pointer<byte_t> Function(ffi.Pointer<wasm_memory_t>)>();

  int wasm_memory_data_size(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_data_size(
      arg0,
    );
  }

  late final _wasm_memory_data_sizePtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<wasm_memory_t>)>>(
      'wasm_memory_data_size');
  late final _wasm_memory_data_size = _wasm_memory_data_sizePtr
      .asFunction<int Function(ffi.Pointer<wasm_memory_t>)>();

  int wasm_memory_size(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_size(
      arg0,
    );
  }

  late final _wasm_memory_sizePtr = _lookup<
      ffi.NativeFunction<
          wasm_memory_pages_t Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_size');
  late final _wasm_memory_size = _wasm_memory_sizePtr
      .asFunction<int Function(ffi.Pointer<wasm_memory_t>)>();

  bool wasm_memory_grow(
    ffi.Pointer<wasm_memory_t> arg0,
    int delta,
  ) {
    return _wasm_memory_grow(
      arg0,
      delta,
    );
  }

  late final _wasm_memory_growPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_memory_t>,
              wasm_memory_pages_t)>>('wasm_memory_grow');
  late final _wasm_memory_grow = _wasm_memory_growPtr
      .asFunction<bool Function(ffi.Pointer<wasm_memory_t>, int)>();

  void wasm_extern_delete(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_delete(
      arg0,
    );
  }

  late final _wasm_extern_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_extern_t>)>>(
      'wasm_extern_delete');
  late final _wasm_extern_delete = _wasm_extern_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_extern_copy(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_copy(
      arg0,
    );
  }

  late final _wasm_extern_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_copy');
  late final _wasm_extern_copy = _wasm_extern_copyPtr.asFunction<
      ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_extern_t>)>();

  bool wasm_extern_same(
    ffi.Pointer<wasm_extern_t> arg0,
    ffi.Pointer<wasm_extern_t> arg1,
  ) {
    return _wasm_extern_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_extern_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_extern_t>,
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_same');
  late final _wasm_extern_same = _wasm_extern_samePtr.asFunction<
      bool Function(ffi.Pointer<wasm_extern_t>, ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<ffi.Void> wasm_extern_get_host_info(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_get_host_info(
      arg0,
    );
  }

  late final _wasm_extern_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_get_host_info');
  late final _wasm_extern_get_host_info = _wasm_extern_get_host_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_extern_t>)>();

  void wasm_extern_set_host_info(
    ffi.Pointer<wasm_extern_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_extern_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_extern_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_extern_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_extern_set_host_info');
  late final _wasm_extern_set_host_info =
      _wasm_extern_set_host_infoPtr.asFunction<
          void Function(ffi.Pointer<wasm_extern_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_extern_set_host_info_with_finalizer(
    ffi.Pointer<wasm_extern_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_extern_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_extern_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_extern_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_extern_set_host_info_with_finalizer');
  late final _wasm_extern_set_host_info_with_finalizer =
      _wasm_extern_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_extern_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_extern_as_ref(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_ref(
      arg0,
    );
  }

  late final _wasm_extern_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_ref');
  late final _wasm_extern_as_ref = _wasm_extern_as_refPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_ref_as_extern(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_extern(
      arg0,
    );
  }

  late final _wasm_ref_as_externPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_extern');
  late final _wasm_ref_as_extern = _wasm_ref_as_externPtr.asFunction<
      ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_extern_as_ref_const(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_ref_const(
      arg0,
    );
  }

  late final _wasm_extern_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_ref_const');
  late final _wasm_extern_as_ref_const =
      _wasm_extern_as_ref_constPtr.asFunction<
          ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_ref_as_extern_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_extern_const(
      arg0,
    );
  }

  late final _wasm_ref_as_extern_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_extern_const');
  late final _wasm_ref_as_extern_const =
      _wasm_ref_as_extern_constPtr.asFunction<
          ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_ref_t>)>();

  void wasm_extern_vec_new_empty(
    ffi.Pointer<wasm_extern_vec_t> out,
  ) {
    return _wasm_extern_vec_new_empty(
      out,
    );
  }

  late final _wasm_extern_vec_new_emptyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_extern_vec_t>)>>(
      'wasm_extern_vec_new_empty');
  late final _wasm_extern_vec_new_empty = _wasm_extern_vec_new_emptyPtr
      .asFunction<void Function(ffi.Pointer<wasm_extern_vec_t>)>();

  void wasm_extern_vec_new_uninitialized(
    ffi.Pointer<wasm_extern_vec_t> out,
    int arg1,
  ) {
    return _wasm_extern_vec_new_uninitialized(
      out,
      arg1,
    );
  }

  late final _wasm_extern_vec_new_uninitializedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_extern_vec_t>,
              ffi.Size)>>('wasm_extern_vec_new_uninitialized');
  late final _wasm_extern_vec_new_uninitialized =
      _wasm_extern_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_extern_vec_t>, int)>();

  void wasm_extern_vec_new(
    ffi.Pointer<wasm_extern_vec_t> out,
    int arg1,
    ffi.Pointer<ffi.Pointer<wasm_extern_t>> arg2,
  ) {
    return _wasm_extern_vec_new(
      out,
      arg1,
      arg2,
    );
  }

  late final _wasm_extern_vec_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_extern_vec_t>, ffi.Size,
              ffi.Pointer<ffi.Pointer<wasm_extern_t>>)>>('wasm_extern_vec_new');
  late final _wasm_extern_vec_new = _wasm_extern_vec_newPtr.asFunction<
      void Function(ffi.Pointer<wasm_extern_vec_t>, int,
          ffi.Pointer<ffi.Pointer<wasm_extern_t>>)>();

  void wasm_extern_vec_copy(
    ffi.Pointer<wasm_extern_vec_t> out,
    ffi.Pointer<wasm_extern_vec_t> arg1,
  ) {
    return _wasm_extern_vec_copy(
      out,
      arg1,
    );
  }

  late final _wasm_extern_vec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_extern_vec_t>,
              ffi.Pointer<wasm_extern_vec_t>)>>('wasm_extern_vec_copy');
  late final _wasm_extern_vec_copy = _wasm_extern_vec_copyPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_extern_vec_t>, ffi.Pointer<wasm_extern_vec_t>)>();

  void wasm_extern_vec_delete(
    ffi.Pointer<wasm_extern_vec_t> arg0,
  ) {
    return _wasm_extern_vec_delete(
      arg0,
    );
  }

  late final _wasm_extern_vec_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasm_extern_vec_t>)>>(
      'wasm_extern_vec_delete');
  late final _wasm_extern_vec_delete = _wasm_extern_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_extern_vec_t>)>();

  int wasm_extern_kind(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_kind(
      arg0,
    );
  }

  late final _wasm_extern_kindPtr = _lookup<
      ffi.NativeFunction<
          wasm_externkind_t Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_kind');
  late final _wasm_extern_kind = _wasm_extern_kindPtr
      .asFunction<int Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_externtype_t> wasm_extern_type(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_type(
      arg0,
    );
  }

  late final _wasm_extern_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_type');
  late final _wasm_extern_type = _wasm_extern_typePtr.asFunction<
      ffi.Pointer<wasm_externtype_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_func_as_extern(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_as_extern(
      arg0,
    );
  }

  late final _wasm_func_as_externPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_func_t>)>>('wasm_func_as_extern');
  late final _wasm_func_as_extern = _wasm_func_as_externPtr.asFunction<
      ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_func_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_global_as_extern(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_as_extern(
      arg0,
    );
  }

  late final _wasm_global_as_externPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_global_t>)>>('wasm_global_as_extern');
  late final _wasm_global_as_extern = _wasm_global_as_externPtr.asFunction<
      ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_global_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_table_as_extern(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_as_extern(
      arg0,
    );
  }

  late final _wasm_table_as_externPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_as_extern');
  late final _wasm_table_as_extern = _wasm_table_as_externPtr.asFunction<
      ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_table_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_memory_as_extern(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_as_extern(
      arg0,
    );
  }

  late final _wasm_memory_as_externPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_as_extern');
  late final _wasm_memory_as_extern = _wasm_memory_as_externPtr.asFunction<
      ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_memory_t>)>();

  ffi.Pointer<wasm_func_t> wasm_extern_as_func(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_func(
      arg0,
    );
  }

  late final _wasm_extern_as_funcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_func_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_func');
  late final _wasm_extern_as_func = _wasm_extern_as_funcPtr.asFunction<
      ffi.Pointer<wasm_func_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_global_t> wasm_extern_as_global(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_global(
      arg0,
    );
  }

  late final _wasm_extern_as_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_global_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_global');
  late final _wasm_extern_as_global = _wasm_extern_as_globalPtr.asFunction<
      ffi.Pointer<wasm_global_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_table_t> wasm_extern_as_table(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_table(
      arg0,
    );
  }

  late final _wasm_extern_as_tablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_table_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_table');
  late final _wasm_extern_as_table = _wasm_extern_as_tablePtr.asFunction<
      ffi.Pointer<wasm_table_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_memory_t> wasm_extern_as_memory(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_memory(
      arg0,
    );
  }

  late final _wasm_extern_as_memoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memory_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_memory');
  late final _wasm_extern_as_memory = _wasm_extern_as_memoryPtr.asFunction<
      ffi.Pointer<wasm_memory_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_func_as_extern_const(
    ffi.Pointer<wasm_func_t> arg0,
  ) {
    return _wasm_func_as_extern_const(
      arg0,
    );
  }

  late final _wasm_func_as_extern_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_func_t>)>>('wasm_func_as_extern_const');
  late final _wasm_func_as_extern_const =
      _wasm_func_as_extern_constPtr.asFunction<
          ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_func_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_global_as_extern_const(
    ffi.Pointer<wasm_global_t> arg0,
  ) {
    return _wasm_global_as_extern_const(
      arg0,
    );
  }

  late final _wasm_global_as_extern_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_global_t>)>>('wasm_global_as_extern_const');
  late final _wasm_global_as_extern_const =
      _wasm_global_as_extern_constPtr.asFunction<
          ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_global_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_table_as_extern_const(
    ffi.Pointer<wasm_table_t> arg0,
  ) {
    return _wasm_table_as_extern_const(
      arg0,
    );
  }

  late final _wasm_table_as_extern_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_table_t>)>>('wasm_table_as_extern_const');
  late final _wasm_table_as_extern_const =
      _wasm_table_as_extern_constPtr.asFunction<
          ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_table_t>)>();

  ffi.Pointer<wasm_extern_t> wasm_memory_as_extern_const(
    ffi.Pointer<wasm_memory_t> arg0,
  ) {
    return _wasm_memory_as_extern_const(
      arg0,
    );
  }

  late final _wasm_memory_as_extern_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_extern_t> Function(
              ffi.Pointer<wasm_memory_t>)>>('wasm_memory_as_extern_const');
  late final _wasm_memory_as_extern_const =
      _wasm_memory_as_extern_constPtr.asFunction<
          ffi.Pointer<wasm_extern_t> Function(ffi.Pointer<wasm_memory_t>)>();

  ffi.Pointer<wasm_func_t> wasm_extern_as_func_const(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_func_const(
      arg0,
    );
  }

  late final _wasm_extern_as_func_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_func_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_func_const');
  late final _wasm_extern_as_func_const =
      _wasm_extern_as_func_constPtr.asFunction<
          ffi.Pointer<wasm_func_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_global_t> wasm_extern_as_global_const(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_global_const(
      arg0,
    );
  }

  late final _wasm_extern_as_global_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_global_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_global_const');
  late final _wasm_extern_as_global_const =
      _wasm_extern_as_global_constPtr.asFunction<
          ffi.Pointer<wasm_global_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_table_t> wasm_extern_as_table_const(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_table_const(
      arg0,
    );
  }

  late final _wasm_extern_as_table_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_table_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_table_const');
  late final _wasm_extern_as_table_const =
      _wasm_extern_as_table_constPtr.asFunction<
          ffi.Pointer<wasm_table_t> Function(ffi.Pointer<wasm_extern_t>)>();

  ffi.Pointer<wasm_memory_t> wasm_extern_as_memory_const(
    ffi.Pointer<wasm_extern_t> arg0,
  ) {
    return _wasm_extern_as_memory_const(
      arg0,
    );
  }

  late final _wasm_extern_as_memory_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memory_t> Function(
              ffi.Pointer<wasm_extern_t>)>>('wasm_extern_as_memory_const');
  late final _wasm_extern_as_memory_const =
      _wasm_extern_as_memory_constPtr.asFunction<
          ffi.Pointer<wasm_memory_t> Function(ffi.Pointer<wasm_extern_t>)>();

  void wasm_instance_delete(
    ffi.Pointer<wasm_instance_t> arg0,
  ) {
    return _wasm_instance_delete(
      arg0,
    );
  }

  late final _wasm_instance_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_instance_t>)>>(
      'wasm_instance_delete');
  late final _wasm_instance_delete = _wasm_instance_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_instance_t>)>();

  ffi.Pointer<wasm_instance_t> wasm_instance_copy(
    ffi.Pointer<wasm_instance_t> arg0,
  ) {
    return _wasm_instance_copy(
      arg0,
    );
  }

  late final _wasm_instance_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_instance_t> Function(
              ffi.Pointer<wasm_instance_t>)>>('wasm_instance_copy');
  late final _wasm_instance_copy = _wasm_instance_copyPtr.asFunction<
      ffi.Pointer<wasm_instance_t> Function(ffi.Pointer<wasm_instance_t>)>();

  bool wasm_instance_same(
    ffi.Pointer<wasm_instance_t> arg0,
    ffi.Pointer<wasm_instance_t> arg1,
  ) {
    return _wasm_instance_same(
      arg0,
      arg1,
    );
  }

  late final _wasm_instance_samePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_instance_t>,
              ffi.Pointer<wasm_instance_t>)>>('wasm_instance_same');
  late final _wasm_instance_same = _wasm_instance_samePtr.asFunction<
      bool Function(
          ffi.Pointer<wasm_instance_t>, ffi.Pointer<wasm_instance_t>)>();

  ffi.Pointer<ffi.Void> wasm_instance_get_host_info(
    ffi.Pointer<wasm_instance_t> arg0,
  ) {
    return _wasm_instance_get_host_info(
      arg0,
    );
  }

  late final _wasm_instance_get_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasm_instance_t>)>>('wasm_instance_get_host_info');
  late final _wasm_instance_get_host_info =
      _wasm_instance_get_host_infoPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasm_instance_t>)>();

  void wasm_instance_set_host_info(
    ffi.Pointer<wasm_instance_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _wasm_instance_set_host_info(
      arg0,
      arg1,
    );
  }

  late final _wasm_instance_set_host_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_instance_t>,
              ffi.Pointer<ffi.Void>)>>('wasm_instance_set_host_info');
  late final _wasm_instance_set_host_info =
      _wasm_instance_set_host_infoPtr.asFunction<
          void Function(ffi.Pointer<wasm_instance_t>, ffi.Pointer<ffi.Void>)>();

  void wasm_instance_set_host_info_with_finalizer(
    ffi.Pointer<wasm_instance_t> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        arg2,
  ) {
    return _wasm_instance_set_host_info_with_finalizer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wasm_instance_set_host_info_with_finalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_instance_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasm_instance_set_host_info_with_finalizer');
  late final _wasm_instance_set_host_info_with_finalizer =
      _wasm_instance_set_host_info_with_finalizerPtr.asFunction<
          void Function(
              ffi.Pointer<wasm_instance_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<wasm_ref_t> wasm_instance_as_ref(
    ffi.Pointer<wasm_instance_t> arg0,
  ) {
    return _wasm_instance_as_ref(
      arg0,
    );
  }

  late final _wasm_instance_as_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_instance_t>)>>('wasm_instance_as_ref');
  late final _wasm_instance_as_ref = _wasm_instance_as_refPtr.asFunction<
      ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_instance_t>)>();

  ffi.Pointer<wasm_instance_t> wasm_ref_as_instance(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_instance(
      arg0,
    );
  }

  late final _wasm_ref_as_instancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_instance_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_instance');
  late final _wasm_ref_as_instance = _wasm_ref_as_instancePtr.asFunction<
      ffi.Pointer<wasm_instance_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_ref_t> wasm_instance_as_ref_const(
    ffi.Pointer<wasm_instance_t> arg0,
  ) {
    return _wasm_instance_as_ref_const(
      arg0,
    );
  }

  late final _wasm_instance_as_ref_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_ref_t> Function(
              ffi.Pointer<wasm_instance_t>)>>('wasm_instance_as_ref_const');
  late final _wasm_instance_as_ref_const =
      _wasm_instance_as_ref_constPtr.asFunction<
          ffi.Pointer<wasm_ref_t> Function(ffi.Pointer<wasm_instance_t>)>();

  ffi.Pointer<wasm_instance_t> wasm_ref_as_instance_const(
    ffi.Pointer<wasm_ref_t> arg0,
  ) {
    return _wasm_ref_as_instance_const(
      arg0,
    );
  }

  late final _wasm_ref_as_instance_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_instance_t> Function(
              ffi.Pointer<wasm_ref_t>)>>('wasm_ref_as_instance_const');
  late final _wasm_ref_as_instance_const =
      _wasm_ref_as_instance_constPtr.asFunction<
          ffi.Pointer<wasm_instance_t> Function(ffi.Pointer<wasm_ref_t>)>();

  ffi.Pointer<wasm_instance_t> wasm_instance_new(
    ffi.Pointer<wasm_store_t> arg0,
    ffi.Pointer<wasm_module_t> arg1,
    ffi.Pointer<wasm_extern_vec_t> imports,
    ffi.Pointer<ffi.Pointer<wasm_trap_t>> arg3,
  ) {
    return _wasm_instance_new(
      arg0,
      arg1,
      imports,
      arg3,
    );
  }

  late final _wasm_instance_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_instance_t> Function(
              ffi.Pointer<wasm_store_t>,
              ffi.Pointer<wasm_module_t>,
              ffi.Pointer<wasm_extern_vec_t>,
              ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>>('wasm_instance_new');
  late final _wasm_instance_new = _wasm_instance_newPtr.asFunction<
      ffi.Pointer<wasm_instance_t> Function(
          ffi.Pointer<wasm_store_t>,
          ffi.Pointer<wasm_module_t>,
          ffi.Pointer<wasm_extern_vec_t>,
          ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>();

  void wasm_instance_exports(
    ffi.Pointer<wasm_instance_t> arg0,
    ffi.Pointer<wasm_extern_vec_t> out,
  ) {
    return _wasm_instance_exports(
      arg0,
      out,
    );
  }

  late final _wasm_instance_exportsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_instance_t>,
              ffi.Pointer<wasm_extern_vec_t>)>>('wasm_instance_exports');
  late final _wasm_instance_exports = _wasm_instance_exportsPtr.asFunction<
      void Function(
          ffi.Pointer<wasm_instance_t>, ffi.Pointer<wasm_extern_vec_t>)>();

  void wasi_config_delete(
    ffi.Pointer<wasi_config_t> arg0,
  ) {
    return _wasi_config_delete(
      arg0,
    );
  }

  late final _wasi_config_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasi_config_t>)>>(
      'wasi_config_delete');
  late final _wasi_config_delete = _wasi_config_deletePtr
      .asFunction<void Function(ffi.Pointer<wasi_config_t>)>();

  /// \brief Creates a new empty configuration object.
  ///
  /// The caller is expected to deallocate the returned configuration
  ffi.Pointer<wasi_config_t> wasi_config_new() {
    return _wasi_config_new();
  }

  late final _wasi_config_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wasi_config_t> Function()>>(
          'wasi_config_new');
  late final _wasi_config_new =
      _wasi_config_newPtr.asFunction<ffi.Pointer<wasi_config_t> Function()>();

  /// \brief Sets the argv list for this configuration object.
  ///
  /// By default WASI programs have an empty argv list, but this can be used to
  /// explicitly specify what the argv list for the program is.
  ///
  /// The arguments are copied into the `config` object as part of this function
  /// call, so the `argv` pointer only needs to stay alive for this function call.
  void wasi_config_set_argv(
    ffi.Pointer<wasi_config_t> config,
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _wasi_config_set_argv(
      config,
      argc,
      argv,
    );
  }

  late final _wasi_config_set_argvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasi_config_t>, ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('wasi_config_set_argv');
  late final _wasi_config_set_argv = _wasi_config_set_argvPtr.asFunction<
      void Function(ffi.Pointer<wasi_config_t>, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// \brief Indicates that the argv list should be inherited from this process's
  /// argv list.
  void wasi_config_inherit_argv(
    ffi.Pointer<wasi_config_t> config,
  ) {
    return _wasi_config_inherit_argv(
      config,
    );
  }

  late final _wasi_config_inherit_argvPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasi_config_t>)>>(
      'wasi_config_inherit_argv');
  late final _wasi_config_inherit_argv = _wasi_config_inherit_argvPtr
      .asFunction<void Function(ffi.Pointer<wasi_config_t>)>();

  /// \brief Sets the list of environment variables available to the WASI instance.
  ///
  /// By default WASI programs have a blank environment, but this can be used to
  /// define some environment variables for them.
  ///
  /// It is required that the `names` and `values` lists both have `envc` entries.
  ///
  /// The env vars are copied into the `config` object as part of this function
  /// call, so the `names` and `values` pointers only need to stay alive for this
  /// function call.
  void wasi_config_set_env(
    ffi.Pointer<wasi_config_t> config,
    int envc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> names,
    ffi.Pointer<ffi.Pointer<ffi.Char>> values,
  ) {
    return _wasi_config_set_env(
      config,
      envc,
      names,
      values,
    );
  }

  late final _wasi_config_set_envPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasi_config_t>,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('wasi_config_set_env');
  late final _wasi_config_set_env = _wasi_config_set_envPtr.asFunction<
      void Function(
          ffi.Pointer<wasi_config_t>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// \brief Indicates that the entire environment of the calling process should be
  /// inherited by this WASI configuration.
  void wasi_config_inherit_env(
    ffi.Pointer<wasi_config_t> config,
  ) {
    return _wasi_config_inherit_env(
      config,
    );
  }

  late final _wasi_config_inherit_envPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasi_config_t>)>>(
      'wasi_config_inherit_env');
  late final _wasi_config_inherit_env = _wasi_config_inherit_envPtr
      .asFunction<void Function(ffi.Pointer<wasi_config_t>)>();

  /// \brief Configures standard input to be taken from the specified file.
  ///
  /// By default WASI programs have no stdin, but this configures the specified
  /// file to be used as stdin for this configuration.
  ///
  /// If the stdin location does not exist or it cannot be opened for reading then
  /// `false` is returned. Otherwise `true` is returned.
  bool wasi_config_set_stdin_file(
    ffi.Pointer<wasi_config_t> config,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _wasi_config_set_stdin_file(
      config,
      path,
    );
  }

  late final _wasi_config_set_stdin_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasi_config_t>,
              ffi.Pointer<ffi.Char>)>>('wasi_config_set_stdin_file');
  late final _wasi_config_set_stdin_file =
      _wasi_config_set_stdin_filePtr.asFunction<
          bool Function(ffi.Pointer<wasi_config_t>, ffi.Pointer<ffi.Char>)>();

  /// \brief Configures standard input to be taken from the specified #wasm_byte_vec_t.
  ///
  /// By default WASI programs have no stdin, but this configures the specified
  /// bytes to be used as stdin for this configuration.
  ///
  /// This function takes ownership of the `binary` argument.
  void wasi_config_set_stdin_bytes(
    ffi.Pointer<wasi_config_t> config,
    ffi.Pointer<wasm_byte_vec_t> binary,
  ) {
    return _wasi_config_set_stdin_bytes(
      config,
      binary,
    );
  }

  late final _wasi_config_set_stdin_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasi_config_t>,
              ffi.Pointer<wasm_byte_vec_t>)>>('wasi_config_set_stdin_bytes');
  late final _wasi_config_set_stdin_bytes =
      _wasi_config_set_stdin_bytesPtr.asFunction<
          void Function(
              ffi.Pointer<wasi_config_t>, ffi.Pointer<wasm_byte_vec_t>)>();

  /// \brief Configures this process's own stdin stream to be used as stdin for
  /// this WASI configuration.
  void wasi_config_inherit_stdin(
    ffi.Pointer<wasi_config_t> config,
  ) {
    return _wasi_config_inherit_stdin(
      config,
    );
  }

  late final _wasi_config_inherit_stdinPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasi_config_t>)>>(
      'wasi_config_inherit_stdin');
  late final _wasi_config_inherit_stdin = _wasi_config_inherit_stdinPtr
      .asFunction<void Function(ffi.Pointer<wasi_config_t>)>();

  /// \brief Configures standard output to be written to the specified file.
  ///
  /// By default WASI programs have no stdout, but this configures the specified
  /// file to be used as stdout.
  ///
  /// If the stdout location could not be opened for writing then `false` is
  /// returned. Otherwise `true` is returned.
  bool wasi_config_set_stdout_file(
    ffi.Pointer<wasi_config_t> config,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _wasi_config_set_stdout_file(
      config,
      path,
    );
  }

  late final _wasi_config_set_stdout_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasi_config_t>,
              ffi.Pointer<ffi.Char>)>>('wasi_config_set_stdout_file');
  late final _wasi_config_set_stdout_file =
      _wasi_config_set_stdout_filePtr.asFunction<
          bool Function(ffi.Pointer<wasi_config_t>, ffi.Pointer<ffi.Char>)>();

  /// \brief Configures this process's own stdout stream to be used as stdout for
  /// this WASI configuration.
  void wasi_config_inherit_stdout(
    ffi.Pointer<wasi_config_t> config,
  ) {
    return _wasi_config_inherit_stdout(
      config,
    );
  }

  late final _wasi_config_inherit_stdoutPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasi_config_t>)>>(
      'wasi_config_inherit_stdout');
  late final _wasi_config_inherit_stdout = _wasi_config_inherit_stdoutPtr
      .asFunction<void Function(ffi.Pointer<wasi_config_t>)>();

  /// \brief Configures standard output to be written to the specified file.
  ///
  /// By default WASI programs have no stderr, but this configures the specified
  /// file to be used as stderr.
  ///
  /// If the stderr location could not be opened for writing then `false` is
  /// returned. Otherwise `true` is returned.
  bool wasi_config_set_stderr_file(
    ffi.Pointer<wasi_config_t> config,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _wasi_config_set_stderr_file(
      config,
      path,
    );
  }

  late final _wasi_config_set_stderr_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasi_config_t>,
              ffi.Pointer<ffi.Char>)>>('wasi_config_set_stderr_file');
  late final _wasi_config_set_stderr_file =
      _wasi_config_set_stderr_filePtr.asFunction<
          bool Function(ffi.Pointer<wasi_config_t>, ffi.Pointer<ffi.Char>)>();

  /// \brief Configures this process's own stderr stream to be used as stderr for
  /// this WASI configuration.
  void wasi_config_inherit_stderr(
    ffi.Pointer<wasi_config_t> config,
  ) {
    return _wasi_config_inherit_stderr(
      config,
    );
  }

  late final _wasi_config_inherit_stderrPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasi_config_t>)>>(
      'wasi_config_inherit_stderr');
  late final _wasi_config_inherit_stderr = _wasi_config_inherit_stderrPtr
      .asFunction<void Function(ffi.Pointer<wasi_config_t>)>();

  /// \brief Configures a "preopened directory" to be available to WASI APIs.
  ///
  /// By default WASI programs do not have access to anything on the filesystem.
  /// This API can be used to grant WASI programs access to a directory on the
  /// filesystem, but only that directory (its whole contents but nothing above it).
  ///
  /// The `path` argument here is a path name on the host filesystem, and
  /// `guest_path` is the name by which it will be known in wasm.
  bool wasi_config_preopen_dir(
    ffi.Pointer<wasi_config_t> config,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> guest_path,
  ) {
    return _wasi_config_preopen_dir(
      config,
      path,
      guest_path,
    );
  }

  late final _wasi_config_preopen_dirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasi_config_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('wasi_config_preopen_dir');
  late final _wasi_config_preopen_dir = _wasi_config_preopen_dirPtr.asFunction<
      bool Function(ffi.Pointer<wasi_config_t>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// \brief Configures a "preopened" listen socket to be available to WASI APIs.
  ///
  /// By default WASI programs do not have access to open up network sockets on
  /// the host. This API can be used to grant WASI programs access to a network
  /// socket file descriptor on the host.
  ///
  /// The fd_num argument is the number of the file descriptor by which it will be
  /// known in WASM and the host_port is the IP address and port (e.g.
  /// "127.0.0.1:8080") requested to listen on.
  bool wasi_config_preopen_socket(
    ffi.Pointer<wasi_config_t> config,
    int fd_num,
    ffi.Pointer<ffi.Char> host_port,
  ) {
    return _wasi_config_preopen_socket(
      config,
      fd_num,
      host_port,
    );
  }

  late final _wasi_config_preopen_socketPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasi_config_t>, ffi.Uint32,
              ffi.Pointer<ffi.Char>)>>('wasi_config_preopen_socket');
  late final _wasi_config_preopen_socket =
      _wasi_config_preopen_socketPtr.asFunction<
          bool Function(
              ffi.Pointer<wasi_config_t>, int, ffi.Pointer<ffi.Char>)>();

  /// \brief Creates a new error with the provided message.
  ffi.Pointer<wasmtime_error_t> wasmtime_error_new(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _wasmtime_error_new(
      arg0,
    );
  }

  late final _wasmtime_error_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<ffi.Char>)>>('wasmtime_error_new');
  late final _wasmtime_error_new = _wasmtime_error_newPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<ffi.Char>)>();

  /// \brief Deletes an error.
  void wasmtime_error_delete(
    ffi.Pointer<wasmtime_error_t> error,
  ) {
    return _wasmtime_error_delete(
      error,
    );
  }

  late final _wasmtime_error_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_error_t>)>>(
      'wasmtime_error_delete');
  late final _wasmtime_error_delete = _wasmtime_error_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_error_t>)>();

  /// \brief Returns the string description of this error.
  ///
  /// This will "render" the error to a string and then return the string
  /// representation of the error to the caller. The `message` argument should be
  /// uninitialized before this function is called and the caller is responsible
  /// for deallocating it with #wasm_byte_vec_delete afterwards.
  void wasmtime_error_message(
    ffi.Pointer<wasmtime_error_t> error,
    ffi.Pointer<wasm_name_t> message,
  ) {
    return _wasmtime_error_message(
      error,
      message,
    );
  }

  late final _wasmtime_error_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_error_t>,
              ffi.Pointer<wasm_name_t>)>>('wasmtime_error_message');
  late final _wasmtime_error_message = _wasmtime_error_messagePtr.asFunction<
      void Function(ffi.Pointer<wasmtime_error_t>, ffi.Pointer<wasm_name_t>)>();

  /// \brief Attempts to extract a WASI-specific exit status from this error.
  ///
  /// Returns `true` if the error is a WASI "exit" trap and has a return status.
  /// If `true` is returned then the exit status is returned through the `status`
  /// pointer. If `false` is returned then this is not a wasi exit trap.
  bool wasmtime_error_exit_status(
    ffi.Pointer<wasmtime_error_t> arg0,
    ffi.Pointer<ffi.Int> status,
  ) {
    return _wasmtime_error_exit_status(
      arg0,
      status,
    );
  }

  late final _wasmtime_error_exit_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasmtime_error_t>,
              ffi.Pointer<ffi.Int>)>>('wasmtime_error_exit_status');
  late final _wasmtime_error_exit_status =
      _wasmtime_error_exit_statusPtr.asFunction<
          bool Function(ffi.Pointer<wasmtime_error_t>, ffi.Pointer<ffi.Int>)>();

  /// \brief Attempts to extract a WebAssembly trace from this error.
  ///
  /// This is similar to #wasm_trap_trace except that it takes a #wasmtime_error_t
  /// as input. The `out` argument will be filled in with the wasm trace, if
  /// present.
  void wasmtime_error_wasm_trace(
    ffi.Pointer<wasmtime_error_t> arg0,
    ffi.Pointer<wasm_frame_vec_t> out,
  ) {
    return _wasmtime_error_wasm_trace(
      arg0,
      out,
    );
  }

  late final _wasmtime_error_wasm_tracePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_error_t>,
              ffi.Pointer<wasm_frame_vec_t>)>>('wasmtime_error_wasm_trace');
  late final _wasmtime_error_wasm_trace =
      _wasmtime_error_wasm_tracePtr.asFunction<
          void Function(
              ffi.Pointer<wasmtime_error_t>, ffi.Pointer<wasm_frame_vec_t>)>();

  /// \brief Configures whether DWARF debug information is constructed at runtime
  /// to describe JIT code.
  ///
  /// This setting is `false` by default. When enabled it will attempt to inform
  /// native debuggers about DWARF debugging information for JIT code to more
  /// easily debug compiled WebAssembly via native debuggers. This can also
  /// sometimes improve the quality of output when profiling is enabled.
  void wasmtime_config_debug_info_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_debug_info_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_debug_info_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_debug_info_set');
  late final _wasmtime_config_debug_info_set =
      _wasmtime_config_debug_info_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Whether or not fuel is enabled for generated code.
  ///
  /// This setting is `false` by default. When enabled it will enable fuel counting
  /// meaning that fuel will be consumed every time a wasm instruction is executed,
  /// and trap when reaching zero.
  void wasmtime_config_consume_fuel_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_consume_fuel_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_consume_fuel_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_consume_fuel_set');
  late final _wasmtime_config_consume_fuel_set =
      _wasmtime_config_consume_fuel_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Whether or not epoch-based interruption is enabled for generated code.
  ///
  /// This setting is `false` by default. When enabled wasm code will check the
  /// current epoch periodically and abort if the current epoch is beyond a
  /// store-configured limit.
  ///
  /// Note that when this setting is enabled all stores will immediately trap and
  /// need to have their epoch deadline otherwise configured with
  /// #wasmtime_context_set_epoch_deadline.
  ///
  /// Note that the current epoch is engine-local and can be incremented with
  /// #wasmtime_engine_increment_epoch.
  void wasmtime_config_epoch_interruption_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_epoch_interruption_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_epoch_interruption_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_epoch_interruption_set');
  late final _wasmtime_config_epoch_interruption_set =
      _wasmtime_config_epoch_interruption_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures the maximum stack size, in bytes, that JIT code can use.
  ///
  /// This setting is 2MB by default. Configuring this setting will limit the
  /// amount of native stack space that JIT code can use while it is executing. If
  /// you're hitting stack overflow you can try making this setting larger, or if
  /// you'd like to limit wasm programs to less stack you can also configure this.
  ///
  /// Note that this setting is not interpreted with 100% precision. Additionally
  /// the amount of stack space that wasm takes is always relative to the first
  /// invocation of wasm on the stack, so recursive calls with host frames in the
  /// middle will all need to fit within this setting.
  void wasmtime_config_max_wasm_stack_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_max_wasm_stack_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_max_wasm_stack_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Size)>>('wasmtime_config_max_wasm_stack_set');
  late final _wasmtime_config_max_wasm_stack_set =
      _wasmtime_config_max_wasm_stack_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configures whether the WebAssembly threading proposal is enabled.
  ///
  /// This setting is `false` by default.
  ///
  /// Note that threads are largely unimplemented in Wasmtime at this time.
  void wasmtime_config_wasm_threads_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_threads_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_threads_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_threads_set');
  late final _wasmtime_config_wasm_threads_set =
      _wasmtime_config_wasm_threads_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly reference types proposal is
  /// enabled.
  ///
  /// This setting is `false` by default.
  void wasmtime_config_wasm_reference_types_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_reference_types_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_reference_types_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_reference_types_set');
  late final _wasmtime_config_wasm_reference_types_set =
      _wasmtime_config_wasm_reference_types_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly SIMD proposal is
  /// enabled.
  ///
  /// This setting is `false` by default.
  void wasmtime_config_wasm_simd_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_simd_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_simd_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_simd_set');
  late final _wasmtime_config_wasm_simd_set = _wasmtime_config_wasm_simd_setPtr
      .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly relaxed SIMD proposal is
  /// enabled.
  ///
  /// This setting is `false` by default.
  void wasmtime_config_wasm_relaxed_simd_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_relaxed_simd_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_relaxed_simd_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_relaxed_simd_set');
  late final _wasmtime_config_wasm_relaxed_simd_set =
      _wasmtime_config_wasm_relaxed_simd_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly relaxed SIMD proposal is
  /// in deterministic mode.
  ///
  /// This setting is `false` by default.
  void wasmtime_config_wasm_relaxed_simd_deterministic_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_relaxed_simd_deterministic_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_relaxed_simd_deterministic_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<wasm_config_t>, ffi.Bool)>>(
      'wasmtime_config_wasm_relaxed_simd_deterministic_set');
  late final _wasmtime_config_wasm_relaxed_simd_deterministic_set =
      _wasmtime_config_wasm_relaxed_simd_deterministic_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly bulk memory proposal is
  /// enabled.
  ///
  /// This setting is `false` by default.
  void wasmtime_config_wasm_bulk_memory_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_bulk_memory_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_bulk_memory_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_bulk_memory_set');
  late final _wasmtime_config_wasm_bulk_memory_set =
      _wasmtime_config_wasm_bulk_memory_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly multi value proposal is
  /// enabled.
  ///
  /// This setting is `true` by default.
  void wasmtime_config_wasm_multi_value_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_multi_value_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_multi_value_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_multi_value_set');
  late final _wasmtime_config_wasm_multi_value_set =
      _wasmtime_config_wasm_multi_value_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly multi-memory proposal is
  /// enabled.
  ///
  /// This setting is `false` by default.
  void wasmtime_config_wasm_multi_memory_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_multi_memory_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_multi_memory_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_multi_memory_set');
  late final _wasmtime_config_wasm_multi_memory_set =
      _wasmtime_config_wasm_multi_memory_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether the WebAssembly memory64 proposal is
  /// enabled.
  ///
  /// This setting is `false` by default.
  void wasmtime_config_wasm_memory64_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_wasm_memory64_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_wasm_memory64_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_wasm_memory64_set');
  late final _wasmtime_config_wasm_memory64_set =
      _wasmtime_config_wasm_memory64_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures how JIT code will be compiled.
  ///
  /// This setting is #WASMTIME_STRATEGY_AUTO by default.
  void wasmtime_config_strategy_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_strategy_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_strategy_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              wasmtime_strategy_t)>>('wasmtime_config_strategy_set');
  late final _wasmtime_config_strategy_set = _wasmtime_config_strategy_setPtr
      .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configure whether wasmtime should compile a module using multiple threads.
  ///
  /// For more information see the Rust documentation at
  /// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.parallel_compilation.
  void wasmtime_config_parallel_compilation_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_parallel_compilation_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_parallel_compilation_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_parallel_compilation_set');
  late final _wasmtime_config_parallel_compilation_set =
      _wasmtime_config_parallel_compilation_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether Cranelift's debug verifier is enabled.
  ///
  /// This setting in `false` by default.
  ///
  /// When cranelift is used for compilation this enables expensive debug checks
  /// within Cranelift itself to verify it's correct.
  void wasmtime_config_cranelift_debug_verifier_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_cranelift_debug_verifier_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_cranelift_debug_verifier_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_cranelift_debug_verifier_set');
  late final _wasmtime_config_cranelift_debug_verifier_set =
      _wasmtime_config_cranelift_debug_verifier_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures whether Cranelift should perform a NaN-canonicalization pass.
  ///
  /// When Cranelift is used as a code generation backend this will configure
  /// it to replace NaNs with a single canonical value. This is useful for users
  /// requiring entirely deterministic WebAssembly computation.
  ///
  /// This is not required by the WebAssembly spec, so it is not enabled by default.
  ///
  /// The default value for this is `false`
  void wasmtime_config_cranelift_nan_canonicalization_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_cranelift_nan_canonicalization_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_cranelift_nan_canonicalization_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_cranelift_nan_canonicalization_set');
  late final _wasmtime_config_cranelift_nan_canonicalization_set =
      _wasmtime_config_cranelift_nan_canonicalization_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures Cranelift's optimization level for JIT code.
  ///
  /// This setting in #WASMTIME_OPT_LEVEL_SPEED by default.
  void wasmtime_config_cranelift_opt_level_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_cranelift_opt_level_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_cranelift_opt_level_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasm_config_t>, wasmtime_opt_level_t)>>(
      'wasmtime_config_cranelift_opt_level_set');
  late final _wasmtime_config_cranelift_opt_level_set =
      _wasmtime_config_cranelift_opt_level_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configures the profiling strategy used for JIT code.
  ///
  /// This setting in #WASMTIME_PROFILING_STRATEGY_NONE by default.
  void wasmtime_config_profiler_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_profiler_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_profiler_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              wasmtime_profiling_strategy_t)>>('wasmtime_config_profiler_set');
  late final _wasmtime_config_profiler_set = _wasmtime_config_profiler_setPtr
      .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configures the “static” style of memory to always be used.
  ///
  /// This setting is `false` by default.
  ///
  /// For more information see the Rust documentation at
  /// https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.static_memory_forced.
  void wasmtime_config_static_memory_forced_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_static_memory_forced_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_static_memory_forced_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_static_memory_forced_set');
  late final _wasmtime_config_static_memory_forced_set =
      _wasmtime_config_static_memory_forced_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Configures the maximum size for memory to be considered "static"
  ///
  /// For more information see the Rust documentation at
  /// https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.static_memory_maximum_size.
  void wasmtime_config_static_memory_maximum_size_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_static_memory_maximum_size_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_static_memory_maximum_size_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Uint64)>>('wasmtime_config_static_memory_maximum_size_set');
  late final _wasmtime_config_static_memory_maximum_size_set =
      _wasmtime_config_static_memory_maximum_size_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configures the guard region size for "static" memory.
  ///
  /// For more information see the Rust documentation at
  /// https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.static_memory_guard_size.
  void wasmtime_config_static_memory_guard_size_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_static_memory_guard_size_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_static_memory_guard_size_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Uint64)>>('wasmtime_config_static_memory_guard_size_set');
  late final _wasmtime_config_static_memory_guard_size_set =
      _wasmtime_config_static_memory_guard_size_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configures the guard region size for "dynamic" memory.
  ///
  /// For more information see the Rust documentation at
  /// https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.dynamic_memory_guard_size.
  void wasmtime_config_dynamic_memory_guard_size_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_dynamic_memory_guard_size_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_dynamic_memory_guard_size_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Uint64)>>('wasmtime_config_dynamic_memory_guard_size_set');
  late final _wasmtime_config_dynamic_memory_guard_size_set =
      _wasmtime_config_dynamic_memory_guard_size_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configures the size, in bytes, of the extra virtual memory space reserved after a “dynamic” memory for growing into.
  ///
  /// For more information see the Rust documentation at
  /// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.dynamic_memory_reserved_for_growth
  void wasmtime_config_dynamic_memory_reserved_for_growth_set(
    ffi.Pointer<wasm_config_t> arg0,
    int arg1,
  ) {
    return _wasmtime_config_dynamic_memory_reserved_for_growth_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_dynamic_memory_reserved_for_growth_setPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<wasm_config_t>, ffi.Uint64)>>(
          'wasmtime_config_dynamic_memory_reserved_for_growth_set');
  late final _wasmtime_config_dynamic_memory_reserved_for_growth_set =
      _wasmtime_config_dynamic_memory_reserved_for_growth_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, int)>();

  /// \brief Configures whether to generate native unwind information (e.g. .eh_frame on Linux).
  ///
  /// This option defaults to true.
  ///
  /// For more information see the Rust documentation at
  /// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.native_unwind_info
  void wasmtime_config_native_unwind_info_set(
    ffi.Pointer<wasm_config_t> arg0,
    bool arg1,
  ) {
    return _wasmtime_config_native_unwind_info_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_native_unwind_info_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Bool)>>('wasmtime_config_native_unwind_info_set');
  late final _wasmtime_config_native_unwind_info_set =
      _wasmtime_config_native_unwind_info_setPtr
          .asFunction<void Function(ffi.Pointer<wasm_config_t>, bool)>();

  /// \brief Enables Wasmtime's cache and loads configuration from the specified
  /// path.
  ///
  /// By default the Wasmtime compilation cache is disabled. The configuration path
  /// here can be `NULL` to use the default settings, and otherwise the argument
  /// here must be a file on the filesystem with TOML configuration -
  /// https://bytecodealliance.github.io/wasmtime/cli-cache.html.
  ///
  /// An error is returned if the cache configuration could not be loaded or if the
  /// cache could not be enabled.
  ffi.Pointer<wasmtime_error_t> wasmtime_config_cache_config_load(
    ffi.Pointer<wasm_config_t> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _wasmtime_config_cache_config_load(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_cache_config_loadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasm_config_t>,
              ffi.Pointer<ffi.Char>)>>('wasmtime_config_cache_config_load');
  late final _wasmtime_config_cache_config_load =
      _wasmtime_config_cache_config_loadPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasm_config_t>, ffi.Pointer<ffi.Char>)>();

  /// \brief Configures the target triple that this configuration will produce
  /// machine code for.
  ///
  /// This option defaults to the native host. Calling this method will
  /// additionally disable inference of the native features of the host (e.g.
  /// detection of SSE4.2 on x86_64 hosts). Native features can be reenabled with
  /// the `cranelift_flag_{set,enable}` properties.
  ///
  /// For more information see the Rust documentation at
  /// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.config
  ffi.Pointer<wasmtime_error_t> wasmtime_config_target_set(
    ffi.Pointer<wasm_config_t> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _wasmtime_config_target_set(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_target_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasm_config_t>,
              ffi.Pointer<ffi.Char>)>>('wasmtime_config_target_set');
  late final _wasmtime_config_target_set =
      _wasmtime_config_target_setPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasm_config_t>, ffi.Pointer<ffi.Char>)>();

  /// \brief Enables a target-specific flag in Cranelift.
  ///
  /// This can be used, for example, to enable SSE4.2 on x86_64 hosts. Settings can
  /// be explored with `wasmtime settings` on the CLI.
  ///
  /// For more information see the Rust documentation at
  /// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.cranelift_flag_enable
  void wasmtime_config_cranelift_flag_enable(
    ffi.Pointer<wasm_config_t> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _wasmtime_config_cranelift_flag_enable(
      arg0,
      arg1,
    );
  }

  late final _wasmtime_config_cranelift_flag_enablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>,
              ffi.Pointer<ffi.Char>)>>('wasmtime_config_cranelift_flag_enable');
  late final _wasmtime_config_cranelift_flag_enable =
      _wasmtime_config_cranelift_flag_enablePtr.asFunction<
          void Function(ffi.Pointer<wasm_config_t>, ffi.Pointer<ffi.Char>)>();

  /// \brief Sets a target-specific flag in Cranelift to the specified value.
  ///
  /// This can be used, for example, to enable SSE4.2 on x86_64 hosts. Settings can
  /// be explored with `wasmtime settings` on the CLI.
  ///
  /// For more information see the Rust documentation at
  /// https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.cranelift_flag_set
  void wasmtime_config_cranelift_flag_set(
    ffi.Pointer<wasm_config_t> arg0,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _wasmtime_config_cranelift_flag_set(
      arg0,
      key,
      value,
    );
  }

  late final _wasmtime_config_cranelift_flag_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_config_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('wasmtime_config_cranelift_flag_set');
  late final _wasmtime_config_cranelift_flag_set =
      _wasmtime_config_cranelift_flag_setPtr.asFunction<
          void Function(ffi.Pointer<wasm_config_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// \brief Increments the engine-local epoch variable.
  ///
  /// This function will increment the engine's current epoch which can be used to
  /// force WebAssembly code to trap if the current epoch goes beyond the
  /// #wasmtime_store_t configured epoch deadline.
  ///
  /// This function is safe to call from any thread, and it is also
  /// async-signal-safe.
  ///
  /// See also #wasmtime_config_epoch_interruption_set.
  void wasmtime_engine_increment_epoch(
    ffi.Pointer<wasm_engine_t> engine,
  ) {
    return _wasmtime_engine_increment_epoch(
      engine,
    );
  }

  late final _wasmtime_engine_increment_epochPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_engine_t>)>>(
      'wasmtime_engine_increment_epoch');
  late final _wasmtime_engine_increment_epoch =
      _wasmtime_engine_increment_epochPtr
          .asFunction<void Function(ffi.Pointer<wasm_engine_t>)>();

  /// \brief Compiles a WebAssembly binary into a #wasmtime_module_t
  ///
  /// This function will compile a WebAssembly binary into an owned #wasm_module_t.
  /// This performs the same as #wasm_module_new except that it returns a
  /// #wasmtime_error_t type to get richer error information.
  ///
  /// On success the returned #wasmtime_error_t is `NULL` and the `ret` pointer is
  /// filled in with a #wasm_module_t. On failure the #wasmtime_error_t is
  /// non-`NULL` and the `ret` pointer is unmodified.
  ///
  /// This function does not take ownership of any of its arguments, but the
  /// returned error and module are owned by the caller.
  ffi.Pointer<wasmtime_error_t> wasmtime_module_new(
    ffi.Pointer<wasm_engine_t> engine,
    ffi.Pointer<ffi.Uint8> wasm,
    int wasm_len,
    ffi.Pointer<ffi.Pointer<wasmtime_module_t>> ret,
  ) {
    return _wasmtime_module_new(
      engine,
      wasm,
      wasm_len,
      ret,
    );
  }

  late final _wasmtime_module_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasm_engine_t>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasmtime_module_t>>)>>(
      'wasmtime_module_new');
  late final _wasmtime_module_new = _wasmtime_module_newPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasm_engine_t>,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Pointer<wasmtime_module_t>>)>();

  /// \brief Deletes a module.
  void wasmtime_module_delete(
    ffi.Pointer<wasmtime_module_t> m,
  ) {
    return _wasmtime_module_delete(
      m,
    );
  }

  late final _wasmtime_module_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_module_t>)>>(
      'wasmtime_module_delete');
  late final _wasmtime_module_delete = _wasmtime_module_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_module_t>)>();

  /// \brief Creates a shallow clone of the specified module, increasing the
  /// internal reference count.
  ffi.Pointer<wasmtime_module_t> wasmtime_module_clone(
    ffi.Pointer<wasmtime_module_t> m,
  ) {
    return _wasmtime_module_clone(
      m,
    );
  }

  late final _wasmtime_module_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_module_t> Function(
              ffi.Pointer<wasmtime_module_t>)>>('wasmtime_module_clone');
  late final _wasmtime_module_clone = _wasmtime_module_clonePtr.asFunction<
      ffi.Pointer<wasmtime_module_t> Function(
          ffi.Pointer<wasmtime_module_t>)>();

  /// \brief Same as #wasm_module_imports, but for #wasmtime_module_t.
  void wasmtime_module_imports(
    ffi.Pointer<wasmtime_module_t> module,
    ffi.Pointer<wasm_importtype_vec_t> out,
  ) {
    return _wasmtime_module_imports(
      module,
      out,
    );
  }

  late final _wasmtime_module_importsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_module_t>,
              ffi.Pointer<wasm_importtype_vec_t>)>>('wasmtime_module_imports');
  late final _wasmtime_module_imports = _wasmtime_module_importsPtr.asFunction<
      void Function(ffi.Pointer<wasmtime_module_t>,
          ffi.Pointer<wasm_importtype_vec_t>)>();

  /// \brief Same as #wasm_module_exports, but for #wasmtime_module_t.
  void wasmtime_module_exports(
    ffi.Pointer<wasmtime_module_t> module,
    ffi.Pointer<wasm_exporttype_vec_t> out,
  ) {
    return _wasmtime_module_exports(
      module,
      out,
    );
  }

  late final _wasmtime_module_exportsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_module_t>,
              ffi.Pointer<wasm_exporttype_vec_t>)>>('wasmtime_module_exports');
  late final _wasmtime_module_exports = _wasmtime_module_exportsPtr.asFunction<
      void Function(ffi.Pointer<wasmtime_module_t>,
          ffi.Pointer<wasm_exporttype_vec_t>)>();

  /// \brief Validate a WebAssembly binary.
  ///
  /// This function will validate the provided byte sequence to determine if it is
  /// a valid WebAssembly binary within the context of the engine provided.
  ///
  /// This function does not take ownership of its arguments but the caller is
  /// expected to deallocate the returned error if it is non-`NULL`.
  ///
  /// If the binary validates then `NULL` is returned, otherwise the error returned
  /// describes why the binary did not validate.
  ffi.Pointer<wasmtime_error_t> wasmtime_module_validate(
    ffi.Pointer<wasm_engine_t> engine,
    ffi.Pointer<ffi.Uint8> wasm,
    int wasm_len,
  ) {
    return _wasmtime_module_validate(
      engine,
      wasm,
      wasm_len,
    );
  }

  late final _wasmtime_module_validatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasm_engine_t>,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('wasmtime_module_validate');
  late final _wasmtime_module_validate =
      _wasmtime_module_validatePtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasm_engine_t>, ffi.Pointer<ffi.Uint8>, int)>();

  /// \brief This function serializes compiled module artifacts as blob data.
  ///
  /// \param module the module
  /// \param ret if the conversion is successful, this byte vector is filled in with
  /// the serialized compiled module.
  ///
  /// \return a non-null error if parsing fails, or returns `NULL`. If parsing
  /// fails then `ret` isn't touched.
  ///
  /// This function does not take ownership of `module`, and the caller is
  /// expected to deallocate the returned #wasmtime_error_t and #wasm_byte_vec_t.
  ffi.Pointer<wasmtime_error_t> wasmtime_module_serialize(
    ffi.Pointer<wasmtime_module_t> module,
    ffi.Pointer<wasm_byte_vec_t> ret,
  ) {
    return _wasmtime_module_serialize(
      module,
      ret,
    );
  }

  late final _wasmtime_module_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasmtime_module_t>,
              ffi.Pointer<wasm_byte_vec_t>)>>('wasmtime_module_serialize');
  late final _wasmtime_module_serialize =
      _wasmtime_module_serializePtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_module_t>, ffi.Pointer<wasm_byte_vec_t>)>();

  /// \brief Build a module from serialized data.
  ///
  /// This function does not take ownership of any of its arguments, but the
  /// returned error and module are owned by the caller.
  ///
  /// This function is not safe to receive arbitrary user input. See the Rust
  /// documentation for more information on what inputs are safe to pass in here
  /// (e.g. only that of #wasmtime_module_serialize)
  ffi.Pointer<wasmtime_error_t> wasmtime_module_deserialize(
    ffi.Pointer<wasm_engine_t> engine,
    ffi.Pointer<ffi.Uint8> bytes,
    int bytes_len,
    ffi.Pointer<ffi.Pointer<wasmtime_module_t>> ret,
  ) {
    return _wasmtime_module_deserialize(
      engine,
      bytes,
      bytes_len,
      ret,
    );
  }

  late final _wasmtime_module_deserializePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasm_engine_t>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasmtime_module_t>>)>>(
      'wasmtime_module_deserialize');
  late final _wasmtime_module_deserialize =
      _wasmtime_module_deserializePtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasm_engine_t>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Pointer<wasmtime_module_t>>)>();

  /// \brief Deserialize a module from an on-disk file.
  ///
  /// This function is the same as #wasmtime_module_deserialize except that it
  /// reads the data for the serialized module from the path on disk. This can be
  /// faster than the alternative which may require copying the data around.
  ///
  /// This function does not take ownership of any of its arguments, but the
  /// returned error and module are owned by the caller.
  ///
  /// This function is not safe to receive arbitrary user input. See the Rust
  /// documentation for more information on what inputs are safe to pass in here
  /// (e.g. only that of #wasmtime_module_serialize)
  ffi.Pointer<wasmtime_error_t> wasmtime_module_deserialize_file(
    ffi.Pointer<wasm_engine_t> engine,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Pointer<wasmtime_module_t>> ret,
  ) {
    return _wasmtime_module_deserialize_file(
      engine,
      path,
      ret,
    );
  }

  late final _wasmtime_module_deserialize_filePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasm_engine_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<wasmtime_module_t>>)>>(
      'wasmtime_module_deserialize_file');
  late final _wasmtime_module_deserialize_file =
      _wasmtime_module_deserialize_filePtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasm_engine_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<wasmtime_module_t>>)>();

  /// \brief Creates a new store within the specified engine.
  ///
  /// \param engine the compilation environment with configuration this store is
  /// connected to
  /// \param data user-provided data to store, can later be acquired with
  /// #wasmtime_context_get_data.
  /// \param finalizer an optional finalizer for `data`
  ///
  /// This function creates a fresh store with the provided configuration settings.
  /// The returned store must be deleted with #wasmtime_store_delete.
  ffi.Pointer<wasmtime_store_t> wasmtime_store_new(
    ffi.Pointer<wasm_engine_t> engine,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        finalizer,
  ) {
    return _wasmtime_store_new(
      engine,
      data,
      finalizer,
    );
  }

  late final _wasmtime_store_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_store_t> Function(
              ffi.Pointer<wasm_engine_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>)>>)>>('wasmtime_store_new');
  late final _wasmtime_store_new = _wasmtime_store_newPtr.asFunction<
      ffi.Pointer<wasmtime_store_t> Function(
          ffi.Pointer<wasm_engine_t>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// \brief Returns the interior #wasmtime_context_t pointer to this store
  ffi.Pointer<wasmtime_context_t> wasmtime_store_context(
    ffi.Pointer<wasmtime_store_t> store,
  ) {
    return _wasmtime_store_context(
      store,
    );
  }

  late final _wasmtime_store_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_context_t> Function(
              ffi.Pointer<wasmtime_store_t>)>>('wasmtime_store_context');
  late final _wasmtime_store_context = _wasmtime_store_contextPtr.asFunction<
      ffi.Pointer<wasmtime_context_t> Function(
          ffi.Pointer<wasmtime_store_t>)>();

  /// \brief Provides limits for a store. Used by hosts to limit resource
  /// consumption of instances. Use negative value to keep the default value
  /// for the limit.
  ///
  /// \param store store where the limits should be set.
  /// \param memory_size the maximum number of bytes a linear memory can grow to.
  /// Growing a linear memory beyond this limit will fail. By default,
  /// linear memory will not be limited.
  /// \param table_elements the maximum number of elements in a table.
  /// Growing a table beyond this limit will fail. By default, table elements
  /// will not be limited.
  /// \param instances the maximum number of instances that can be created
  /// for a Store. Module instantiation will fail if this limit is exceeded.
  /// This value defaults to 10,000.
  /// \param tables the maximum number of tables that can be created for a Store.
  /// Module instantiation will fail if this limit is exceeded. This value
  /// defaults to 10,000.
  /// \param memories the maximum number of linear memories that can be created
  /// for a Store. Instantiation will fail with an error if this limit is exceeded.
  /// This value defaults to 10,000.
  ///
  /// Use any negative value for the parameters that should be kept on
  /// the default values.
  ///
  /// Note that the limits are only used to limit the creation/growth of
  /// resources in the future, this does not retroactively attempt to apply
  /// limits to the store.
  void wasmtime_store_limiter(
    ffi.Pointer<wasmtime_store_t> store,
    int memory_size,
    int table_elements,
    int instances,
    int tables,
    int memories,
  ) {
    return _wasmtime_store_limiter(
      store,
      memory_size,
      table_elements,
      instances,
      tables,
      memories,
    );
  }

  late final _wasmtime_store_limiterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_store_t>, ffi.Int64, ffi.Int64,
              ffi.Int64, ffi.Int64, ffi.Int64)>>('wasmtime_store_limiter');
  late final _wasmtime_store_limiter = _wasmtime_store_limiterPtr.asFunction<
      void Function(ffi.Pointer<wasmtime_store_t>, int, int, int, int, int)>();

  /// \brief Deletes a store.
  void wasmtime_store_delete(
    ffi.Pointer<wasmtime_store_t> store,
  ) {
    return _wasmtime_store_delete(
      store,
    );
  }

  late final _wasmtime_store_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_store_t>)>>(
      'wasmtime_store_delete');
  late final _wasmtime_store_delete = _wasmtime_store_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_store_t>)>();

  /// \brief Returns the user-specified data associated with the specified store
  ffi.Pointer<ffi.Void> wasmtime_context_get_data(
    ffi.Pointer<wasmtime_context_t> context,
  ) {
    return _wasmtime_context_get_data(
      context,
    );
  }

  late final _wasmtime_context_get_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasmtime_context_t>)>>('wasmtime_context_get_data');
  late final _wasmtime_context_get_data =
      _wasmtime_context_get_dataPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasmtime_context_t>)>();

  /// \brief Overwrites the user-specified data associated with this store.
  ///
  /// Note that this does not execute the original finalizer for the provided data,
  /// and the original finalizer will be executed for the provided data when the
  /// store is deleted.
  void wasmtime_context_set_data(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _wasmtime_context_set_data(
      context,
      data,
    );
  }

  late final _wasmtime_context_set_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Void>)>>('wasmtime_context_set_data');
  late final _wasmtime_context_set_data =
      _wasmtime_context_set_dataPtr.asFunction<
          void Function(
              ffi.Pointer<wasmtime_context_t>, ffi.Pointer<ffi.Void>)>();

  /// \brief Perform garbage collection within the given context.
  ///
  /// Garbage collects `externref`s that are used within this store. Any
  /// `externref`s that are discovered to be unreachable by other code or objects
  /// will have their finalizers run.
  ///
  /// The `context` argument must not be NULL.
  void wasmtime_context_gc(
    ffi.Pointer<wasmtime_context_t> context,
  ) {
    return _wasmtime_context_gc(
      context,
    );
  }

  late final _wasmtime_context_gcPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_context_t>)>>(
      'wasmtime_context_gc');
  late final _wasmtime_context_gc = _wasmtime_context_gcPtr
      .asFunction<void Function(ffi.Pointer<wasmtime_context_t>)>();

  /// \brief Adds fuel to this context's store for wasm to consume while executing.
  ///
  /// For this method to work fuel consumption must be enabled via
  /// #wasmtime_config_consume_fuel_set. By default a store starts with 0 fuel
  /// for wasm to execute with (meaning it will immediately trap).
  /// This function must be called for the store to have
  /// some fuel to allow WebAssembly to execute.
  ///
  /// Note that at this time when fuel is entirely consumed it will cause
  /// wasm to trap. More usages of fuel are planned for the future.
  ///
  /// If fuel is not enabled within this store then an error is returned. If fuel
  /// is successfully added then NULL is returned.
  ffi.Pointer<wasmtime_error_t> wasmtime_context_add_fuel(
    ffi.Pointer<wasmtime_context_t> store,
    int fuel,
  ) {
    return _wasmtime_context_add_fuel(
      store,
      fuel,
    );
  }

  late final _wasmtime_context_add_fuelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Uint64)>>('wasmtime_context_add_fuel');
  late final _wasmtime_context_add_fuel =
      _wasmtime_context_add_fuelPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>, int)>();

  /// \brief Returns the amount of fuel consumed by this context's store execution
  /// so far.
  ///
  /// If fuel consumption is not enabled via #wasmtime_config_consume_fuel_set
  /// then this function will return false. Otherwise true is returned and the
  /// fuel parameter is filled in with fuel consumed so far.
  ///
  /// Also note that fuel, if enabled, must be originally configured via
  /// #wasmtime_context_add_fuel.
  bool wasmtime_context_fuel_consumed(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<ffi.Uint64> fuel,
  ) {
    return _wasmtime_context_fuel_consumed(
      context,
      fuel,
    );
  }

  late final _wasmtime_context_fuel_consumedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Uint64>)>>('wasmtime_context_fuel_consumed');
  late final _wasmtime_context_fuel_consumed =
      _wasmtime_context_fuel_consumedPtr.asFunction<
          bool Function(
              ffi.Pointer<wasmtime_context_t>, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Returns the amount of fuel remaining in this context's store execution
  /// before engine traps execution.
  ///
  /// If fuel consumption is not enabled via #wasmtime_config_consume_fuel_set
  /// then this function will return false. Otherwise true is returned and the
  /// fuel parameter is filled in with remaining fuel.
  ///
  /// Also note that fuel, if enabled, must be originally configured via
  /// #wasmtime_context_add_fuel.
  bool wasmtime_context_fuel_remaining(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<ffi.Uint64> fuel,
  ) {
    return _wasmtime_context_fuel_remaining(
      context,
      fuel,
    );
  }

  late final _wasmtime_context_fuel_remainingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Uint64>)>>('wasmtime_context_fuel_remaining');
  late final _wasmtime_context_fuel_remaining =
      _wasmtime_context_fuel_remainingPtr.asFunction<
          bool Function(
              ffi.Pointer<wasmtime_context_t>, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Attempt to manually consume fuel from the store.
  ///
  /// If fuel consumption is not enabled via #wasmtime_config_consume_fuel_set then
  /// this function will return an error. Otherwise this will attempt to consume
  /// the specified amount of `fuel` from the store. If successful the remaining
  /// amount of fuel is stored into `remaining`. If `fuel` couldn't be consumed
  /// then an error is returned.
  ///
  /// Also note that fuel, if enabled, must be originally configured via
  /// #wasmtime_context_add_fuel.
  ffi.Pointer<wasmtime_error_t> wasmtime_context_consume_fuel(
    ffi.Pointer<wasmtime_context_t> context,
    int fuel,
    ffi.Pointer<ffi.Uint64> remaining,
  ) {
    return _wasmtime_context_consume_fuel(
      context,
      fuel,
      remaining,
    );
  }

  late final _wasmtime_context_consume_fuelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('wasmtime_context_consume_fuel');
  late final _wasmtime_context_consume_fuel =
      _wasmtime_context_consume_fuelPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>, int, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Configures WASI state within the specified store.
  ///
  /// This function is required if #wasmtime_linker_define_wasi is called. This
  /// will configure the WASI state for instances defined within this store to the
  /// configuration specified.
  ///
  /// This function does not take ownership of `context` but it does take ownership
  /// of `wasi`. The caller should no longer use `wasi` after calling this function
  /// (even if an error is returned).
  ffi.Pointer<wasmtime_error_t> wasmtime_context_set_wasi(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<wasi_config_t> wasi,
  ) {
    return _wasmtime_context_set_wasi(
      context,
      wasi,
    );
  }

  late final _wasmtime_context_set_wasiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasi_config_t>)>>('wasmtime_context_set_wasi');
  late final _wasmtime_context_set_wasi =
      _wasmtime_context_set_wasiPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasi_config_t>)>();

  /// \brief Configures the relative deadline at which point WebAssembly code will
  /// trap or invoke the callback function.
  ///
  /// This function configures the store-local epoch deadline after which point
  /// WebAssembly code will trap or invoke the callback function.
  ///
  /// See also #wasmtime_config_epoch_interruption_set and
  /// #wasmtime_store_epoch_deadline_callback.
  void wasmtime_context_set_epoch_deadline(
    ffi.Pointer<wasmtime_context_t> context,
    int ticks_beyond_current,
  ) {
    return _wasmtime_context_set_epoch_deadline(
      context,
      ticks_beyond_current,
    );
  }

  late final _wasmtime_context_set_epoch_deadlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Uint64)>>('wasmtime_context_set_epoch_deadline');
  late final _wasmtime_context_set_epoch_deadline =
      _wasmtime_context_set_epoch_deadlinePtr
          .asFunction<void Function(ffi.Pointer<wasmtime_context_t>, int)>();

  /// \brief Configures epoch deadline callback to C function.
  ///
  /// This function configures a store-local callback function that will be
  /// called when the running WebAssembly function has exceeded its epoch
  /// deadline. That function can return a #wasmtime_error_t to terminate
  /// the function, or set the delta argument and return NULL to update the
  /// epoch deadline and resume function execution.
  ///
  /// See also #wasmtime_config_epoch_interruption_set and
  /// #wasmtime_context_set_epoch_deadline.
  void wasmtime_store_epoch_deadline_callback(
    ffi.Pointer<wasmtime_store_t> store,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Pointer<wasmtime_error_t> Function(
                    ffi.Pointer<wasmtime_context_t>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Uint64>)>>
        func,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _wasmtime_store_epoch_deadline_callback(
      store,
      func,
      data,
    );
  }

  late final _wasmtime_store_epoch_deadline_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<wasmtime_store_t>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<wasmtime_error_t> Function(
                              ffi.Pointer<wasmtime_context_t>,
                              ffi.Pointer<ffi.Void>,
                              ffi.Pointer<ffi.Uint64>)>>,
                  ffi.Pointer<ffi.Void>)>>(
      'wasmtime_store_epoch_deadline_callback');
  late final _wasmtime_store_epoch_deadline_callback =
      _wasmtime_store_epoch_deadline_callbackPtr.asFunction<
          void Function(
              ffi.Pointer<wasmtime_store_t>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<wasmtime_error_t> Function(
                          ffi.Pointer<wasmtime_context_t>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Uint64>)>>,
              ffi.Pointer<ffi.Void>)>();

  /// \brief Deletes a #wasmtime_extern_t.
  void wasmtime_extern_delete(
    ffi.Pointer<wasmtime_extern_t> val,
  ) {
    return _wasmtime_extern_delete(
      val,
    );
  }

  late final _wasmtime_extern_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_extern_t>)>>(
      'wasmtime_extern_delete');
  late final _wasmtime_extern_delete = _wasmtime_extern_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_extern_t>)>();

  /// \brief Returns the type of the #wasmtime_extern_t defined within the given
  /// store.
  ///
  /// Does not take ownership of `context` or `val`, but the returned
  /// #wasm_externtype_t is an owned value that needs to be deleted.
  ffi.Pointer<wasm_externtype_t> wasmtime_extern_type(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<wasmtime_extern_t> val,
  ) {
    return _wasmtime_extern_type(
      context,
      val,
    );
  }

  late final _wasmtime_extern_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_externtype_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_extern_t>)>>('wasmtime_extern_type');
  late final _wasmtime_extern_type = _wasmtime_extern_typePtr.asFunction<
      ffi.Pointer<wasm_externtype_t> Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_extern_t>)>();

  /// \brief Create a new `externref` value.
  ///
  /// Creates a new `externref` value wrapping the provided data, returning the
  /// pointer to the externref.
  ///
  /// \param data the host-specific data to wrap
  /// \param finalizer an optional finalizer for `data`
  ///
  /// When the reference is reclaimed, the wrapped data is cleaned up with the
  /// provided `finalizer`.
  ///
  /// The returned value must be deleted with #wasmtime_externref_delete
  ffi.Pointer<wasmtime_externref_t> wasmtime_externref_new(
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        finalizer,
  ) {
    return _wasmtime_externref_new(
      data,
      finalizer,
    );
  }

  late final _wasmtime_externref_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_externref_t> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>)>>)>>('wasmtime_externref_new');
  late final _wasmtime_externref_new = _wasmtime_externref_newPtr.asFunction<
      ffi.Pointer<wasmtime_externref_t> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// \brief Get an `externref`'s wrapped data
  ///
  /// Returns the original `data` passed to #wasmtime_externref_new. It is required
  /// that `data` is not `NULL`.
  ffi.Pointer<ffi.Void> wasmtime_externref_data(
    ffi.Pointer<wasmtime_externref_t> data,
  ) {
    return _wasmtime_externref_data(
      data,
    );
  }

  late final _wasmtime_externref_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<wasmtime_externref_t>)>>('wasmtime_externref_data');
  late final _wasmtime_externref_data = _wasmtime_externref_dataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasmtime_externref_t>)>();

  /// \brief Creates a shallow copy of the `externref` argument, returning a
  /// separately owned pointer (increases the reference count).
  ffi.Pointer<wasmtime_externref_t> wasmtime_externref_clone(
    ffi.Pointer<wasmtime_externref_t> ref,
  ) {
    return _wasmtime_externref_clone(
      ref,
    );
  }

  late final _wasmtime_externref_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_externref_t> Function(
              ffi.Pointer<wasmtime_externref_t>)>>('wasmtime_externref_clone');
  late final _wasmtime_externref_clone =
      _wasmtime_externref_clonePtr.asFunction<
          ffi.Pointer<wasmtime_externref_t> Function(
              ffi.Pointer<wasmtime_externref_t>)>();

  /// \brief Decrements the reference count of the `ref`, deleting it if it's the
  /// last reference.
  void wasmtime_externref_delete(
    ffi.Pointer<wasmtime_externref_t> ref,
  ) {
    return _wasmtime_externref_delete(
      ref,
    );
  }

  late final _wasmtime_externref_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasmtime_externref_t>)>>('wasmtime_externref_delete');
  late final _wasmtime_externref_delete = _wasmtime_externref_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_externref_t>)>();

  /// \brief Converts a raw `externref` value coming from #wasmtime_val_raw_t into
  /// a #wasmtime_externref_t.
  ///
  /// Note that the returned #wasmtime_externref_t is an owned value that must be
  /// deleted via #wasmtime_externref_delete by the caller if it is non-null.
  ffi.Pointer<wasmtime_externref_t> wasmtime_externref_from_raw(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<ffi.Void> raw,
  ) {
    return _wasmtime_externref_from_raw(
      context,
      raw,
    );
  }

  late final _wasmtime_externref_from_rawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_externref_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Void>)>>('wasmtime_externref_from_raw');
  late final _wasmtime_externref_from_raw =
      _wasmtime_externref_from_rawPtr.asFunction<
          ffi.Pointer<wasmtime_externref_t> Function(
              ffi.Pointer<wasmtime_context_t>, ffi.Pointer<ffi.Void>)>();

  /// \brief Converts a #wasmtime_externref_t to a raw value suitable for storing
  /// into a #wasmtime_val_raw_t.
  ///
  /// Note that the returned underlying value is not tracked by Wasmtime's garbage
  /// collector until it enters WebAssembly. This means that a GC may release the
  /// context's reference to the raw value, making the raw value invalid within the
  /// context of the store. Do not perform a GC between calling this function and
  /// passing it to WebAssembly.
  ffi.Pointer<ffi.Void> wasmtime_externref_to_raw(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<wasmtime_externref_t> ref,
  ) {
    return _wasmtime_externref_to_raw(
      context,
      ref,
    );
  }

  late final _wasmtime_externref_to_rawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_externref_t>)>>('wasmtime_externref_to_raw');
  late final _wasmtime_externref_to_raw =
      _wasmtime_externref_to_rawPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_externref_t>)>();

  /// \brief Deletes an owned #wasmtime_val_t.
  ///
  /// Note that this only deletes the contents, not the memory that `val` points to
  /// itself (which is owned by the caller).
  void wasmtime_val_delete(
    ffi.Pointer<wasmtime_val_t> val,
  ) {
    return _wasmtime_val_delete(
      val,
    );
  }

  late final _wasmtime_val_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_val_t>)>>(
      'wasmtime_val_delete');
  late final _wasmtime_val_delete = _wasmtime_val_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_val_t>)>();

  /// \brief Copies `src` into `dst`.
  void wasmtime_val_copy(
    ffi.Pointer<wasmtime_val_t> dst,
    ffi.Pointer<wasmtime_val_t> src,
  ) {
    return _wasmtime_val_copy(
      dst,
      src,
    );
  }

  late final _wasmtime_val_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_val_t>,
              ffi.Pointer<wasmtime_val_t>)>>('wasmtime_val_copy');
  late final _wasmtime_val_copy = _wasmtime_val_copyPtr.asFunction<
      void Function(
          ffi.Pointer<wasmtime_val_t>, ffi.Pointer<wasmtime_val_t>)>();

  /// \brief Creates a new host-defined function.
  ///
  /// Inserts a host-defined function into the `store` provided which can be used
  /// to then instantiate a module with or define within a #wasmtime_linker_t.
  ///
  /// \param store the store in which to create the function
  /// \param type the wasm type of the function that's being created
  /// \param callback the host-defined callback to invoke
  /// \param env host-specific data passed to the callback invocation, can be
  /// `NULL`
  /// \param finalizer optional finalizer for `env`, can be `NULL`
  /// \param ret the #wasmtime_func_t return value to be filled in.
  ///
  /// The returned function can only be used with the specified `store`.
  void wasmtime_func_new(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasm_functype_t> type,
    wasmtime_func_callback_t callback,
    ffi.Pointer<ffi.Void> env,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        finalizer,
    ffi.Pointer<wasmtime_func_t> ret,
  ) {
    return _wasmtime_func_new(
      store,
      type,
      callback,
      env,
      finalizer,
      ret,
    );
  }

  late final _wasmtime_func_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasm_functype_t>,
              wasmtime_func_callback_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<wasmtime_func_t>)>>('wasmtime_func_new');
  late final _wasmtime_func_new = _wasmtime_func_newPtr.asFunction<
      void Function(
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasm_functype_t>,
          wasmtime_func_callback_t,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<wasmtime_func_t>)>();

  /// \brief Creates a new host function in the same manner of #wasmtime_func_new,
  /// but the function-to-call has no type information available at runtime.
  ///
  /// This function is very similar to #wasmtime_func_new. The difference is that
  /// this version is "more unsafe" in that when the host callback is invoked there
  /// is no type information and no checks that the right types of values are
  /// produced. The onus is on the consumer of this API to ensure that all
  /// invariants are upheld such as:
  ///
  /// * The host callback reads parameters correctly and interprets their types
  /// correctly.
  /// * If a trap doesn't happen then all results are written to the results
  /// pointer. All results must have the correct type.
  /// * Types such as `funcref` cannot cross stores.
  /// * Types such as `externref` have valid reference counts.
  ///
  /// It's generally only recommended to use this if your application can wrap
  /// this in a safe embedding. This should not be frequently used due to the
  /// number of invariants that must be upheld on the wasm<->host boundary. On the
  /// upside, though, this flavor of host function will be faster to call than
  /// those created by #wasmtime_func_new (hence the reason for this function's
  /// existence).
  void wasmtime_func_new_unchecked(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasm_functype_t> type,
    wasmtime_func_unchecked_callback_t callback,
    ffi.Pointer<ffi.Void> env,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        finalizer,
    ffi.Pointer<wasmtime_func_t> ret,
  ) {
    return _wasmtime_func_new_unchecked(
      store,
      type,
      callback,
      env,
      finalizer,
      ret,
    );
  }

  late final _wasmtime_func_new_uncheckedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasm_functype_t>,
              wasmtime_func_unchecked_callback_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<wasmtime_func_t>)>>('wasmtime_func_new_unchecked');
  late final _wasmtime_func_new_unchecked =
      _wasmtime_func_new_uncheckedPtr.asFunction<
          void Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasm_functype_t>,
              wasmtime_func_unchecked_callback_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<wasmtime_func_t>)>();

  /// \brief Returns the type of the function specified
  ///
  /// The returned #wasm_functype_t is owned by the caller.
  ffi.Pointer<wasm_functype_t> wasmtime_func_type(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_func_t> func,
  ) {
    return _wasmtime_func_type(
      store,
      func,
    );
  }

  late final _wasmtime_func_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_functype_t> Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_func_t>)>>('wasmtime_func_type');
  late final _wasmtime_func_type = _wasmtime_func_typePtr.asFunction<
      ffi.Pointer<wasm_functype_t> Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_func_t>)>();

  /// \brief Call a WebAssembly function.
  ///
  /// This function is used to invoke a function defined within a store. For
  /// example this might be used after extracting a function from a
  /// #wasmtime_instance_t.
  ///
  /// \param store the store which owns `func`
  /// \param func the function to call
  /// \param args the arguments to the function call
  /// \param nargs the number of arguments provided
  /// \param results where to write the results of the function call
  /// \param nresults the number of results expected
  /// \param trap where to store a trap, if one happens.
  ///
  /// There are three possible return states from this function:
  ///
  /// 1. The returned error is non-null. This means `results`
  /// wasn't written to and `trap` will have `NULL` written to it. This state
  /// means that programmer error happened when calling the function, for
  /// example when the size of the arguments/results was wrong, the types of the
  /// arguments were wrong, or arguments may come from the wrong store.
  /// 2. The trap pointer is filled in. This means the returned error is `NULL` and
  /// `results` was not written to. This state means that the function was
  /// executing but hit a wasm trap while executing.
  /// 3. The error and trap returned are both `NULL` and `results` are written to.
  /// This means that the function call succeeded and the specified results were
  /// produced.
  ///
  /// The `trap` pointer cannot be `NULL`. The `args` and `results` pointers may be
  /// `NULL` if the corresponding length is zero.
  ///
  /// Does not take ownership of #wasmtime_val_t arguments. Gives ownership of
  /// #wasmtime_val_t results.
  ffi.Pointer<wasmtime_error_t> wasmtime_func_call(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_func_t> func,
    ffi.Pointer<wasmtime_val_t> args,
    int nargs,
    ffi.Pointer<wasmtime_val_t> results,
    int nresults,
    ffi.Pointer<ffi.Pointer<wasm_trap_t>> trap,
  ) {
    return _wasmtime_func_call(
      store,
      func,
      args,
      nargs,
      results,
      nresults,
      trap,
    );
  }

  late final _wasmtime_func_callPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_func_t>,
              ffi.Pointer<wasmtime_val_t>,
              ffi.Size,
              ffi.Pointer<wasmtime_val_t>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>>('wasmtime_func_call');
  late final _wasmtime_func_call = _wasmtime_func_callPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_func_t>,
          ffi.Pointer<wasmtime_val_t>,
          int,
          ffi.Pointer<wasmtime_val_t>,
          int,
          ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>();

  /// \brief Call a WebAssembly function in an "unchecked" fashion.
  ///
  /// This function is similar to #wasmtime_func_call except that there is no type
  /// information provided with the arguments (or sizing information). Consequently
  /// this is less safe to call since it's up to the caller to ensure that `args`
  /// has an appropriate size and all the parameters are configured with their
  /// appropriate values/types. Additionally all the results must be interpreted
  /// correctly if this function returns successfully.
  ///
  /// Parameters must be specified starting at index 0 in the `args_and_results`
  /// array. Results are written starting at index 0, which will overwrite
  /// the arguments.
  ///
  /// Callers must ensure that various correctness variants are upheld when this
  /// API is called such as:
  ///
  /// * The `args_and_results` pointer has enough space to hold all the parameters
  /// and all the results (but not at the same time).
  /// * The `args_and_results_len` contains the length of the `args_and_results`
  /// buffer.
  /// * Parameters must all be configured as if they were the correct type.
  /// * Values such as `externref` and `funcref` are valid within the store being
  /// called.
  ///
  /// When in doubt it's much safer to call #wasmtime_func_call. This function is
  /// faster than that function, but the tradeoff is that embeddings must uphold
  /// more invariants rather than relying on Wasmtime to check them for you.
  ffi.Pointer<wasmtime_error_t> wasmtime_func_call_unchecked(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_func_t> func,
    ffi.Pointer<wasmtime_val_raw_t> args_and_results,
    int args_and_results_len,
    ffi.Pointer<ffi.Pointer<wasm_trap_t>> trap,
  ) {
    return _wasmtime_func_call_unchecked(
      store,
      func,
      args_and_results,
      args_and_results_len,
      trap,
    );
  }

  late final _wasmtime_func_call_uncheckedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasmtime_context_t>,
                  ffi.Pointer<wasmtime_func_t>,
                  ffi.Pointer<wasmtime_val_raw_t>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>>(
      'wasmtime_func_call_unchecked');
  late final _wasmtime_func_call_unchecked =
      _wasmtime_func_call_uncheckedPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_func_t>,
              ffi.Pointer<wasmtime_val_raw_t>,
              int,
              ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>();

  /// \brief Loads a #wasmtime_extern_t from the caller's context
  ///
  /// This function will attempt to look up the export named `name` on the caller
  /// instance provided. If it is found then the #wasmtime_extern_t for that is
  /// returned, otherwise `NULL` is returned.
  ///
  /// Note that this only works for exported memories right now for WASI
  /// compatibility.
  ///
  /// \param caller the caller object to look up the export from
  /// \param name the name that's being looked up
  /// \param name_len the byte length of `name`
  /// \param item where to store the return value
  ///
  /// Returns a nonzero value if the export was found, or 0 if the export wasn't
  /// found. If the export wasn't found then `item` isn't written to.
  bool wasmtime_caller_export_get(
    ffi.Pointer<wasmtime_caller_t> caller,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasmtime_extern_t> item,
  ) {
    return _wasmtime_caller_export_get(
      caller,
      name,
      name_len,
      item,
    );
  }

  late final _wasmtime_caller_export_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<wasmtime_caller_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<wasmtime_extern_t>)>>('wasmtime_caller_export_get');
  late final _wasmtime_caller_export_get =
      _wasmtime_caller_export_getPtr.asFunction<
          bool Function(ffi.Pointer<wasmtime_caller_t>, ffi.Pointer<ffi.Char>,
              int, ffi.Pointer<wasmtime_extern_t>)>();

  /// \brief Returns the store context of the caller object.
  ffi.Pointer<wasmtime_context_t> wasmtime_caller_context(
    ffi.Pointer<wasmtime_caller_t> caller,
  ) {
    return _wasmtime_caller_context(
      caller,
    );
  }

  late final _wasmtime_caller_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_context_t> Function(
              ffi.Pointer<wasmtime_caller_t>)>>('wasmtime_caller_context');
  late final _wasmtime_caller_context = _wasmtime_caller_contextPtr.asFunction<
      ffi.Pointer<wasmtime_context_t> Function(
          ffi.Pointer<wasmtime_caller_t>)>();

  /// \brief Converts a `raw` nonzero `funcref` value from #wasmtime_val_raw_t
  /// into a #wasmtime_func_t.
  ///
  /// This function can be used to interpret nonzero values of the `funcref` field
  /// of the #wasmtime_val_raw_t structure. It is assumed that `raw` does not have
  /// a value of 0, or otherwise the program will abort.
  ///
  /// Note that this function is unchecked and unsafe. It's only safe to pass
  /// values learned from #wasmtime_val_raw_t with the same corresponding
  /// #wasmtime_context_t that they were produced from. Providing arbitrary values
  /// to `raw` here or cross-context values with `context` is UB.
  void wasmtime_func_from_raw(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<ffi.Void> raw,
    ffi.Pointer<wasmtime_func_t> ret,
  ) {
    return _wasmtime_func_from_raw(
      context,
      raw,
      ret,
    );
  }

  late final _wasmtime_func_from_rawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<wasmtime_func_t>)>>('wasmtime_func_from_raw');
  late final _wasmtime_func_from_raw = _wasmtime_func_from_rawPtr.asFunction<
      void Function(ffi.Pointer<wasmtime_context_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<wasmtime_func_t>)>();

  /// \brief Converts a `func`  which belongs to `context` into a `usize`
  /// parameter that is suitable for insertion into a #wasmtime_val_raw_t.
  ffi.Pointer<ffi.Void> wasmtime_func_to_raw(
    ffi.Pointer<wasmtime_context_t> context,
    ffi.Pointer<wasmtime_func_t> func,
  ) {
    return _wasmtime_func_to_raw(
      context,
      func,
    );
  }

  late final _wasmtime_func_to_rawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_func_t>)>>('wasmtime_func_to_raw');
  late final _wasmtime_func_to_raw = _wasmtime_func_to_rawPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_func_t>)>();

  /// \brief Creates a new global value.
  ///
  /// Creates a new host-defined global value within the provided `store`
  ///
  /// \param store the store in which to create the global
  /// \param type the wasm type of the global being created
  /// \param val the initial value of the global
  /// \param ret a return pointer for the created global.
  ///
  /// This function may return an error if the `val` argument does not match the
  /// specified type of the global, or if `val` comes from a different store than
  /// the one provided.
  ///
  /// This function does not take ownership of any of its arguments but error is
  /// owned by the caller.
  ffi.Pointer<wasmtime_error_t> wasmtime_global_new(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasm_globaltype_t> type,
    ffi.Pointer<wasmtime_val_t> val,
    ffi.Pointer<wasmtime_global_t> ret,
  ) {
    return _wasmtime_global_new(
      store,
      type,
      val,
      ret,
    );
  }

  late final _wasmtime_global_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasm_globaltype_t>,
              ffi.Pointer<wasmtime_val_t>,
              ffi.Pointer<wasmtime_global_t>)>>('wasmtime_global_new');
  late final _wasmtime_global_new = _wasmtime_global_newPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasm_globaltype_t>,
          ffi.Pointer<wasmtime_val_t>,
          ffi.Pointer<wasmtime_global_t>)>();

  /// \brief Returns the wasm type of the specified global.
  ///
  /// The returned #wasm_globaltype_t is owned by the caller.
  ffi.Pointer<wasm_globaltype_t> wasmtime_global_type(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_global_t> global,
  ) {
    return _wasmtime_global_type(
      store,
      global,
    );
  }

  late final _wasmtime_global_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_globaltype_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_global_t>)>>('wasmtime_global_type');
  late final _wasmtime_global_type = _wasmtime_global_typePtr.asFunction<
      ffi.Pointer<wasm_globaltype_t> Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_global_t>)>();

  /// \brief Get the value of the specified global.
  ///
  /// \param store the store that owns `global`
  /// \param global the global to get
  /// \param out where to store the value in this global.
  ///
  /// This function returns ownership of the contents of `out`, so
  /// #wasmtime_val_delete may need to be called on the value.
  void wasmtime_global_get(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_global_t> global,
    ffi.Pointer<wasmtime_val_t> out,
  ) {
    return _wasmtime_global_get(
      store,
      global,
      out,
    );
  }

  late final _wasmtime_global_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_global_t>,
              ffi.Pointer<wasmtime_val_t>)>>('wasmtime_global_get');
  late final _wasmtime_global_get = _wasmtime_global_getPtr.asFunction<
      void Function(ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_global_t>, ffi.Pointer<wasmtime_val_t>)>();

  /// \brief Sets a global to a new value.
  ///
  /// \param store the store that owns `global`
  /// \param global the global to set
  /// \param val the value to store in the global
  ///
  /// This function may return an error if `global` is not mutable or if `val` has
  /// the wrong type for `global`.
  ///
  /// THis does not take ownership of any argument but returns ownership of the error.
  ffi.Pointer<wasmtime_error_t> wasmtime_global_set(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_global_t> global,
    ffi.Pointer<wasmtime_val_t> val,
  ) {
    return _wasmtime_global_set(
      store,
      global,
      val,
    );
  }

  late final _wasmtime_global_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_global_t>,
              ffi.Pointer<wasmtime_val_t>)>>('wasmtime_global_set');
  late final _wasmtime_global_set = _wasmtime_global_setPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_global_t>, ffi.Pointer<wasmtime_val_t>)>();

  /// \brief Instantiate a wasm module.
  ///
  /// This function will instantiate a WebAssembly module with the provided
  /// imports, creating a WebAssembly instance. The returned instance can then
  /// afterwards be inspected for exports.
  ///
  /// \param store the store in which to create the instance
  /// \param module the module that's being instantiated
  /// \param imports the imports provided to the module
  /// \param nimports the size of `imports`
  /// \param instance where to store the returned instance
  /// \param trap where to store the returned trap
  ///
  /// This function requires that `imports` is the same size as the imports that
  /// `module` has. Additionally the `imports` array must be 1:1 lined up with the
  /// imports of the `module` specified. This is intended to be relatively low
  /// level, and #wasmtime_linker_instantiate is provided for a more ergonomic
  /// name-based resolution API.
  ///
  /// The states of return values from this function are similar to
  /// #wasmtime_func_call where an error can be returned meaning something like a
  /// link error in this context. A trap can be returned (meaning no error or
  /// instance is returned), or an instance can be returned (meaning no error or
  /// trap is returned).
  ///
  /// Note that this function requires that all `imports` specified must be owned
  /// by the `store` provided as well.
  ///
  /// This function does not take ownership of any of its arguments, but all return
  /// values are owned by the caller.
  ffi.Pointer<wasmtime_error_t> wasmtime_instance_new(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_module_t> module,
    ffi.Pointer<wasmtime_extern_t> imports,
    int nimports,
    ffi.Pointer<wasmtime_instance_t> instance,
    ffi.Pointer<ffi.Pointer<wasm_trap_t>> trap,
  ) {
    return _wasmtime_instance_new(
      store,
      module,
      imports,
      nimports,
      instance,
      trap,
    );
  }

  late final _wasmtime_instance_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_module_t>,
              ffi.Pointer<wasmtime_extern_t>,
              ffi.Size,
              ffi.Pointer<wasmtime_instance_t>,
              ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>>('wasmtime_instance_new');
  late final _wasmtime_instance_new = _wasmtime_instance_newPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_module_t>,
          ffi.Pointer<wasmtime_extern_t>,
          int,
          ffi.Pointer<wasmtime_instance_t>,
          ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>();

  /// \brief Get an export by name from an instance.
  ///
  /// \param store the store that owns `instance`
  /// \param instance the instance to lookup within
  /// \param name the export name to lookup
  /// \param name_len the byte length of `name`
  /// \param item where to store the returned value
  ///
  /// Returns nonzero if the export was found, and `item` is filled in. Otherwise
  /// returns 0.
  ///
  /// Doesn't take ownership of any arguments but does return ownership of the
  /// #wasmtime_extern_t.
  bool wasmtime_instance_export_get(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_instance_t> instance,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasmtime_extern_t> item,
  ) {
    return _wasmtime_instance_export_get(
      store,
      instance,
      name,
      name_len,
      item,
    );
  }

  late final _wasmtime_instance_export_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_instance_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<wasmtime_extern_t>)>>('wasmtime_instance_export_get');
  late final _wasmtime_instance_export_get =
      _wasmtime_instance_export_getPtr.asFunction<
          bool Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_instance_t>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<wasmtime_extern_t>)>();

  /// \brief Get an export by index from an instance.
  ///
  /// \param store the store that owns `instance`
  /// \param instance the instance to lookup within
  /// \param index the index to lookup
  /// \param name where to store the name of the export
  /// \param name_len where to store the byte length of the name
  /// \param item where to store the export itself
  ///
  /// Returns nonzero if the export was found, and `name`, `name_len`, and `item`
  /// are filled in. Otherwise returns 0.
  ///
  /// Doesn't take ownership of any arguments but does return ownership of the
  /// #wasmtime_extern_t. The `name` pointer return value is owned by the `store`
  /// and must be immediately used before calling any other APIs on
  /// #wasmtime_context_t.
  bool wasmtime_instance_export_nth(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_instance_t> instance,
    int index,
    ffi.Pointer<ffi.Pointer<ffi.Char>> name,
    ffi.Pointer<ffi.Size> name_len,
    ffi.Pointer<wasmtime_extern_t> item,
  ) {
    return _wasmtime_instance_export_nth(
      store,
      instance,
      index,
      name,
      name_len,
      item,
    );
  }

  late final _wasmtime_instance_export_nthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_instance_t>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<wasmtime_extern_t>)>>('wasmtime_instance_export_nth');
  late final _wasmtime_instance_export_nth =
      _wasmtime_instance_export_nthPtr.asFunction<
          bool Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_instance_t>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<wasmtime_extern_t>)>();

  /// \brief Creates a new linker for the specified engine.
  ///
  /// This function does not take ownership of the engine argument, and the caller
  /// is expected to delete the returned linker.
  ffi.Pointer<wasmtime_linker_t> wasmtime_linker_new(
    ffi.Pointer<wasm_engine_t> engine,
  ) {
    return _wasmtime_linker_new(
      engine,
    );
  }

  late final _wasmtime_linker_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_linker_t> Function(
              ffi.Pointer<wasm_engine_t>)>>('wasmtime_linker_new');
  late final _wasmtime_linker_new = _wasmtime_linker_newPtr.asFunction<
      ffi.Pointer<wasmtime_linker_t> Function(ffi.Pointer<wasm_engine_t>)>();

  /// \brief Deletes a linker
  void wasmtime_linker_delete(
    ffi.Pointer<wasmtime_linker_t> linker,
  ) {
    return _wasmtime_linker_delete(
      linker,
    );
  }

  late final _wasmtime_linker_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_linker_t>)>>(
      'wasmtime_linker_delete');
  late final _wasmtime_linker_delete = _wasmtime_linker_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_linker_t>)>();

  /// \brief Configures whether this linker allows later definitions to shadow
  /// previous definitions.
  ///
  /// By default this setting is `false`.
  void wasmtime_linker_allow_shadowing(
    ffi.Pointer<wasmtime_linker_t> linker,
    bool allow_shadowing,
  ) {
    return _wasmtime_linker_allow_shadowing(
      linker,
      allow_shadowing,
    );
  }

  late final _wasmtime_linker_allow_shadowingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasmtime_linker_t>,
              ffi.Bool)>>('wasmtime_linker_allow_shadowing');
  late final _wasmtime_linker_allow_shadowing =
      _wasmtime_linker_allow_shadowingPtr
          .asFunction<void Function(ffi.Pointer<wasmtime_linker_t>, bool)>();

  /// \brief Defines a new item in this linker.
  ///
  /// \param linker the linker the name is being defined in.
  /// \param store the store that the `item` is owned by.
  /// \param module the module name the item is defined under.
  /// \param module_len the byte length of `module`
  /// \param name the field name the item is defined under
  /// \param name_len the byte length of `name`
  /// \param item the item that is being defined in this linker.
  ///
  /// \return On success `NULL` is returned, otherwise an error is returned which
  /// describes why the definition failed.
  ///
  /// For more information about name resolution consult the [Rust
  /// documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#name-resolution).
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_define(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<ffi.Char> module,
    int module_len,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasmtime_extern_t> item,
  ) {
    return _wasmtime_linker_define(
      linker,
      store,
      module,
      module_len,
      name,
      name_len,
      item,
    );
  }

  late final _wasmtime_linker_definePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<wasmtime_extern_t>)>>('wasmtime_linker_define');
  late final _wasmtime_linker_define = _wasmtime_linker_definePtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasmtime_linker_t>,
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<wasmtime_extern_t>)>();

  /// \brief Defines a new function in this linker.
  ///
  /// \param linker the linker the name is being defined in.
  /// \param module the module name the item is defined under.
  /// \param module_len the byte length of `module`
  /// \param name the field name the item is defined under
  /// \param name_len the byte length of `name`
  /// \param ty the type of the function that's being defined
  /// \param cb the host callback to invoke when the function is called
  /// \param data the host-provided data to provide as the first argument to the callback
  /// \param finalizer an optional finalizer for the `data` argument.
  ///
  /// \return On success `NULL` is returned, otherwise an error is returned which
  /// describes why the definition failed.
  ///
  /// For more information about name resolution consult the [Rust
  /// documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#name-resolution).
  ///
  /// Note that this function does not create a #wasmtime_func_t. This creates a
  /// store-independent function within the linker, allowing this function
  /// definition to be used with multiple stores.
  ///
  /// For more information about host callbacks see #wasmtime_func_new.
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_define_func(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<ffi.Char> module,
    int module_len,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasm_functype_t> ty,
    wasmtime_func_callback_t cb,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        finalizer,
  ) {
    return _wasmtime_linker_define_func(
      linker,
      module,
      module_len,
      name,
      name_len,
      ty,
      cb,
      data,
      finalizer,
    );
  }

  late final _wasmtime_linker_define_funcPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasmtime_linker_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<wasm_functype_t>,
                  wasmtime_func_callback_t,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasmtime_linker_define_func');
  late final _wasmtime_linker_define_func =
      _wasmtime_linker_define_funcPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<wasm_functype_t>,
              wasmtime_func_callback_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// \brief Defines a new function in this linker.
  ///
  /// This is the same as #wasmtime_linker_define_func except that it's the analog
  /// of #wasmtime_func_new_unchecked instead of #wasmtime_func_new. Be sure to
  /// consult the documentation of #wasmtime_linker_define_func for argument
  /// information as well as #wasmtime_func_new_unchecked for why this is an
  /// unsafe API.
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_define_func_unchecked(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<ffi.Char> module,
    int module_len,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasm_functype_t> ty,
    wasmtime_func_unchecked_callback_t cb,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        finalizer,
  ) {
    return _wasmtime_linker_define_func_unchecked(
      linker,
      module,
      module_len,
      name,
      name_len,
      ty,
      cb,
      data,
      finalizer,
    );
  }

  late final _wasmtime_linker_define_func_uncheckedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasmtime_linker_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<wasm_functype_t>,
                  wasmtime_func_unchecked_callback_t,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'wasmtime_linker_define_func_unchecked');
  late final _wasmtime_linker_define_func_unchecked =
      _wasmtime_linker_define_func_uncheckedPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<wasm_functype_t>,
              wasmtime_func_unchecked_callback_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// \brief Defines WASI functions in this linker.
  ///
  /// \param linker the linker the name is being defined in.
  ///
  /// \return On success `NULL` is returned, otherwise an error is returned which
  /// describes why the definition failed.
  ///
  /// This function will provide WASI function names in the specified linker. Note
  /// that when an instance is created within a store then the store also needs to
  /// have its WASI settings configured with #wasmtime_context_set_wasi for WASI
  /// functions to work, otherwise an assert will be tripped that will abort the
  /// process.
  ///
  /// For more information about name resolution consult the [Rust
  /// documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#name-resolution).
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_define_wasi(
    ffi.Pointer<wasmtime_linker_t> linker,
  ) {
    return _wasmtime_linker_define_wasi(
      linker,
    );
  }

  late final _wasmtime_linker_define_wasiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>)>>('wasmtime_linker_define_wasi');
  late final _wasmtime_linker_define_wasi =
      _wasmtime_linker_define_wasiPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>)>();

  /// \brief Defines an instance under the specified name in this linker.
  ///
  /// \param linker the linker the name is being defined in.
  /// \param store the store that owns `instance`
  /// \param name the module name to define `instance` under.
  /// \param name_len the byte length of `name`
  /// \param instance a previously-created instance.
  ///
  /// \return On success `NULL` is returned, otherwise an error is returned which
  /// describes why the definition failed.
  ///
  /// This function will take all of the exports of the `instance` provided and
  /// defined them under a module called `name` with a field name as the export's
  /// own name.
  ///
  /// For more information about name resolution consult the [Rust
  /// documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#name-resolution).
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_define_instance(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasmtime_instance_t> instance,
  ) {
    return _wasmtime_linker_define_instance(
      linker,
      store,
      name,
      name_len,
      instance,
    );
  }

  late final _wasmtime_linker_define_instancePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasmtime_linker_t>,
                  ffi.Pointer<wasmtime_context_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<wasmtime_instance_t>)>>(
      'wasmtime_linker_define_instance');
  late final _wasmtime_linker_define_instance =
      _wasmtime_linker_define_instancePtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<wasmtime_instance_t>)>();

  /// \brief Instantiates a #wasm_module_t with the items defined in this linker.
  ///
  /// \param linker the linker used to instantiate the provided module.
  /// \param store the store that is used to instantiate within
  /// \param module the module that is being instantiated.
  /// \param instance the returned instance, if successful.
  /// \param trap a trap returned, if the start function traps.
  ///
  /// \return One of three things can happen as a result of this function. First
  /// the module could be successfully instantiated and returned through
  /// `instance`, meaning the return value and `trap` are both set to `NULL`.
  /// Second the start function may trap, meaning the return value and `instance`
  /// are set to `NULL` and `trap` describes the trap that happens. Finally
  /// instantiation may fail for another reason, in which case an error is returned
  /// and `trap` and `instance` are set to `NULL`.
  ///
  /// This function will attempt to satisfy all of the imports of the `module`
  /// provided with items previously defined in this linker. If any name isn't
  /// defined in the linker than an error is returned. (or if the previously
  /// defined item is of the wrong type).
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_instantiate(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_module_t> module,
    ffi.Pointer<wasmtime_instance_t> instance,
    ffi.Pointer<ffi.Pointer<wasm_trap_t>> trap,
  ) {
    return _wasmtime_linker_instantiate(
      linker,
      store,
      module,
      instance,
      trap,
    );
  }

  late final _wasmtime_linker_instantiatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<wasmtime_error_t> Function(
                  ffi.Pointer<wasmtime_linker_t>,
                  ffi.Pointer<wasmtime_context_t>,
                  ffi.Pointer<wasmtime_module_t>,
                  ffi.Pointer<wasmtime_instance_t>,
                  ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>>(
      'wasmtime_linker_instantiate');
  late final _wasmtime_linker_instantiate =
      _wasmtime_linker_instantiatePtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_module_t>,
              ffi.Pointer<wasmtime_instance_t>,
              ffi.Pointer<ffi.Pointer<wasm_trap_t>>)>();

  /// \brief Defines automatic instantiations of a #wasm_module_t in this linker.
  ///
  /// \param linker the linker the module is being added to
  /// \param store the store that is used to instantiate `module`
  /// \param name the name of the module within the linker
  /// \param name_len the byte length of `name`
  /// \param module the module that's being instantiated
  ///
  /// \return An error if the module could not be instantiated or added or `NULL`
  /// on success.
  ///
  /// This function automatically handles [Commands and
  /// Reactors](https://github.com/WebAssembly/WASI/blob/master/design/application-abi.md#current-unstable-abi)
  /// instantiation and initialization.
  ///
  /// For more information see the [Rust
  /// documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#method.module).
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_module(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasmtime_module_t> module,
  ) {
    return _wasmtime_linker_module(
      linker,
      store,
      name,
      name_len,
      module,
    );
  }

  late final _wasmtime_linker_modulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<wasmtime_module_t>)>>('wasmtime_linker_module');
  late final _wasmtime_linker_module = _wasmtime_linker_modulePtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasmtime_linker_t>,
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<wasmtime_module_t>)>();

  /// \brief Acquires the "default export" of the named module in this linker.
  ///
  /// \param linker the linker to load from
  /// \param store the store to load a function into
  /// \param name the name of the module to get the default export for
  /// \param name_len the byte length of `name`
  /// \param func where to store the extracted default function.
  ///
  /// \return An error is returned if the default export could not be found, or
  /// `NULL` is returned and `func` is filled in otherwise.
  ///
  /// For more information see the [Rust
  /// documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Linker.html#method.get_default).
  ffi.Pointer<wasmtime_error_t> wasmtime_linker_get_default(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasmtime_func_t> func,
  ) {
    return _wasmtime_linker_get_default(
      linker,
      store,
      name,
      name_len,
      func,
    );
  }

  late final _wasmtime_linker_get_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<wasmtime_func_t>)>>('wasmtime_linker_get_default');
  late final _wasmtime_linker_get_default =
      _wasmtime_linker_get_defaultPtr.asFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<wasmtime_func_t>)>();

  /// \brief Loads an item by name from this linker.
  ///
  /// \param linker the linker to load from
  /// \param store the store to load the item into
  /// \param module the name of the module to get
  /// \param module_len the byte length of `module`
  /// \param name the name of the field to get
  /// \param name_len the byte length of `name`
  /// \param item where to store the extracted item
  ///
  /// \return A nonzero value if the item is defined, in which case `item` is also
  /// filled in. Otherwise zero is returned.
  bool wasmtime_linker_get(
    ffi.Pointer<wasmtime_linker_t> linker,
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<ffi.Char> module,
    int module_len,
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<wasmtime_extern_t> item,
  ) {
    return _wasmtime_linker_get(
      linker,
      store,
      module,
      module_len,
      name,
      name_len,
      item,
    );
  }

  late final _wasmtime_linker_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<wasmtime_linker_t>,
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<wasmtime_extern_t>)>>('wasmtime_linker_get');
  late final _wasmtime_linker_get = _wasmtime_linker_getPtr.asFunction<
      bool Function(
          ffi.Pointer<wasmtime_linker_t>,
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<wasmtime_extern_t>)>();

  /// \brief Creates a new memory type from the specified parameters.
  ///
  /// Note that this function is preferred over #wasm_memorytype_new for
  /// compatibility with the memory64 proposal.
  ffi.Pointer<wasm_memorytype_t> wasmtime_memorytype_new(
    int min,
    bool max_present,
    int max,
    bool is_64,
  ) {
    return _wasmtime_memorytype_new(
      min,
      max_present,
      max,
      is_64,
    );
  }

  late final _wasmtime_memorytype_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memorytype_t> Function(ffi.Uint64, ffi.Bool,
              ffi.Uint64, ffi.Bool)>>('wasmtime_memorytype_new');
  late final _wasmtime_memorytype_new = _wasmtime_memorytype_newPtr.asFunction<
      ffi.Pointer<wasm_memorytype_t> Function(int, bool, int, bool)>();

  /// \brief Returns the minimum size, in pages, of the specified memory type.
  ///
  /// Note that this function is preferred over #wasm_memorytype_limits for
  /// compatibility with the memory64 proposal.
  int wasmtime_memorytype_minimum(
    ffi.Pointer<wasm_memorytype_t> ty,
  ) {
    return _wasmtime_memorytype_minimum(
      ty,
    );
  }

  late final _wasmtime_memorytype_minimumPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint64 Function(ffi.Pointer<wasm_memorytype_t>)>>(
      'wasmtime_memorytype_minimum');
  late final _wasmtime_memorytype_minimum = _wasmtime_memorytype_minimumPtr
      .asFunction<int Function(ffi.Pointer<wasm_memorytype_t>)>();

  /// \brief Returns the maximum size, in pages, of the specified memory type.
  ///
  /// If this memory type doesn't have a maximum size listed then `false` is
  /// returned. Otherwise `true` is returned and the `max` pointer is filled in
  /// with the specified maximum size, in pages.
  ///
  /// Note that this function is preferred over #wasm_memorytype_limits for
  /// compatibility with the memory64 proposal.
  bool wasmtime_memorytype_maximum(
    ffi.Pointer<wasm_memorytype_t> ty,
    ffi.Pointer<ffi.Uint64> max,
  ) {
    return _wasmtime_memorytype_maximum(
      ty,
      max,
    );
  }

  late final _wasmtime_memorytype_maximumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_memorytype_t>,
              ffi.Pointer<ffi.Uint64>)>>('wasmtime_memorytype_maximum');
  late final _wasmtime_memorytype_maximum =
      _wasmtime_memorytype_maximumPtr.asFunction<
          bool Function(
              ffi.Pointer<wasm_memorytype_t>, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Returns whether this type of memory represents a 64-bit memory.
  bool wasmtime_memorytype_is64(
    ffi.Pointer<wasm_memorytype_t> ty,
  ) {
    return _wasmtime_memorytype_is64(
      ty,
    );
  }

  late final _wasmtime_memorytype_is64Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<wasm_memorytype_t>)>>(
      'wasmtime_memorytype_is64');
  late final _wasmtime_memorytype_is64 = _wasmtime_memorytype_is64Ptr
      .asFunction<bool Function(ffi.Pointer<wasm_memorytype_t>)>();

  /// \brief Creates a new WebAssembly linear memory
  ///
  /// \param store the store to create the memory within
  /// \param ty the type of the memory to create
  /// \param ret where to store the returned memory
  ///
  /// If an error happens when creating the memory it's returned and owned by the
  /// caller. If an error happens then `ret` is not filled in.
  ffi.Pointer<wasmtime_error_t> wasmtime_memory_new(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasm_memorytype_t> ty,
    ffi.Pointer<wasmtime_memory_t> ret,
  ) {
    return _wasmtime_memory_new(
      store,
      ty,
      ret,
    );
  }

  late final _wasmtime_memory_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasm_memorytype_t>,
              ffi.Pointer<wasmtime_memory_t>)>>('wasmtime_memory_new');
  late final _wasmtime_memory_new = _wasmtime_memory_newPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasm_memorytype_t>, ffi.Pointer<wasmtime_memory_t>)>();

  /// \brief Returns the type of the memory specified
  ffi.Pointer<wasm_memorytype_t> wasmtime_memory_type(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_memory_t> memory,
  ) {
    return _wasmtime_memory_type(
      store,
      memory,
    );
  }

  late final _wasmtime_memory_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_memorytype_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_memory_t>)>>('wasmtime_memory_type');
  late final _wasmtime_memory_type = _wasmtime_memory_typePtr.asFunction<
      ffi.Pointer<wasm_memorytype_t> Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_memory_t>)>();

  /// \brief Returns the base pointer in memory where the linear memory starts.
  ffi.Pointer<ffi.Uint8> wasmtime_memory_data(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_memory_t> memory,
  ) {
    return _wasmtime_memory_data(
      store,
      memory,
    );
  }

  late final _wasmtime_memory_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_memory_t>)>>('wasmtime_memory_data');
  late final _wasmtime_memory_data = _wasmtime_memory_dataPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_memory_t>)>();

  /// \brief Returns the byte length of this linear memory.
  int wasmtime_memory_data_size(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_memory_t> memory,
  ) {
    return _wasmtime_memory_data_size(
      store,
      memory,
    );
  }

  late final _wasmtime_memory_data_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_memory_t>)>>('wasmtime_memory_data_size');
  late final _wasmtime_memory_data_size =
      _wasmtime_memory_data_sizePtr.asFunction<
          int Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_memory_t>)>();

  /// \brief Returns the length, in WebAssembly pages, of this linear memory
  int wasmtime_memory_size(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_memory_t> memory,
  ) {
    return _wasmtime_memory_size(
      store,
      memory,
    );
  }

  late final _wasmtime_memory_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_memory_t>)>>('wasmtime_memory_size');
  late final _wasmtime_memory_size = _wasmtime_memory_sizePtr.asFunction<
      int Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_memory_t>)>();

  /// \brief Attempts to grow the specified memory by `delta` pages.
  ///
  /// \param store the store that owns `memory`
  /// \param memory the memory to grow
  /// \param delta the number of pages to grow by
  /// \param prev_size where to store the previous size of memory
  ///
  /// If memory cannot be grown then `prev_size` is left unchanged and an error is
  /// returned. Otherwise `prev_size` is set to the previous size of the memory, in
  /// WebAssembly pages, and `NULL` is returned.
  ffi.Pointer<wasmtime_error_t> wasmtime_memory_grow(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_memory_t> memory,
    int delta,
    ffi.Pointer<ffi.Uint64> prev_size,
  ) {
    return _wasmtime_memory_grow(
      store,
      memory,
      delta,
      prev_size,
    );
  }

  late final _wasmtime_memory_growPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_memory_t>,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('wasmtime_memory_grow');
  late final _wasmtime_memory_grow = _wasmtime_memory_growPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_memory_t>, int, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Creates a new host-defined wasm table.
  ///
  /// \param store the store to create the table within
  /// \param ty the type of the table to create
  /// \param init the initial value for this table's elements
  /// \param table where to store the returned table
  ///
  /// This function does not take ownership of any of its parameters, but yields
  /// ownership of returned error. This function may return an error if the `init`
  /// value does not match `ty`, for example.
  ffi.Pointer<wasmtime_error_t> wasmtime_table_new(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasm_tabletype_t> ty,
    ffi.Pointer<wasmtime_val_t> init,
    ffi.Pointer<wasmtime_table_t> table,
  ) {
    return _wasmtime_table_new(
      store,
      ty,
      init,
      table,
    );
  }

  late final _wasmtime_table_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasm_tabletype_t>,
              ffi.Pointer<wasmtime_val_t>,
              ffi.Pointer<wasmtime_table_t>)>>('wasmtime_table_new');
  late final _wasmtime_table_new = _wasmtime_table_newPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasm_tabletype_t>,
          ffi.Pointer<wasmtime_val_t>,
          ffi.Pointer<wasmtime_table_t>)>();

  /// \brief Returns the type of this table.
  ///
  /// The caller has ownership of the returned #wasm_tabletype_t
  ffi.Pointer<wasm_tabletype_t> wasmtime_table_type(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_table_t> table,
  ) {
    return _wasmtime_table_type(
      store,
      table,
    );
  }

  late final _wasmtime_table_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_tabletype_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_table_t>)>>('wasmtime_table_type');
  late final _wasmtime_table_type = _wasmtime_table_typePtr.asFunction<
      ffi.Pointer<wasm_tabletype_t> Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_table_t>)>();

  /// \brief Gets a value in a table.
  ///
  /// \param store the store that owns `table`
  /// \param table the table to access
  /// \param index the table index to access
  /// \param val where to store the table's value
  ///
  /// This function will attempt to access a table element. If a nonzero value is
  /// returned then `val` is filled in and is owned by the caller. Otherwise zero
  /// is returned because the `index` is out-of-bounds.
  bool wasmtime_table_get(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_table_t> table,
    int index,
    ffi.Pointer<wasmtime_val_t> val,
  ) {
    return _wasmtime_table_get(
      store,
      table,
      index,
      val,
    );
  }

  late final _wasmtime_table_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_table_t>,
              ffi.Uint32,
              ffi.Pointer<wasmtime_val_t>)>>('wasmtime_table_get');
  late final _wasmtime_table_get = _wasmtime_table_getPtr.asFunction<
      bool Function(ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_table_t>, int, ffi.Pointer<wasmtime_val_t>)>();

  /// \brief Sets a value in a table.
  ///
  /// \param store the store that owns `table`
  /// \param table the table to write to
  /// \param index the table index to write
  /// \param value the value to store.
  ///
  /// This function will store `value` into the specified index in the table. This
  /// does not take ownership of any argument but yields ownership of the error.
  /// This function can fail if `value` has the wrong type for the table, or if
  /// `index` is out of bounds.
  ffi.Pointer<wasmtime_error_t> wasmtime_table_set(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_table_t> table,
    int index,
    ffi.Pointer<wasmtime_val_t> value,
  ) {
    return _wasmtime_table_set(
      store,
      table,
      index,
      value,
    );
  }

  late final _wasmtime_table_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_table_t>,
              ffi.Uint32,
              ffi.Pointer<wasmtime_val_t>)>>('wasmtime_table_set');
  late final _wasmtime_table_set = _wasmtime_table_setPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_table_t>, int, ffi.Pointer<wasmtime_val_t>)>();

  /// \brief Returns the size, in elements, of the specified table
  int wasmtime_table_size(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_table_t> table,
  ) {
    return _wasmtime_table_size(
      store,
      table,
    );
  }

  late final _wasmtime_table_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_table_t>)>>('wasmtime_table_size');
  late final _wasmtime_table_size = _wasmtime_table_sizePtr.asFunction<
      int Function(
          ffi.Pointer<wasmtime_context_t>, ffi.Pointer<wasmtime_table_t>)>();

  /// \brief Grows a table.
  ///
  /// \param store the store that owns `table`
  /// \param table the table to grow
  /// \param delta the number of elements to grow the table by
  /// \param init the initial value for new table element slots
  /// \param prev_size where to store the previous size of the table before growth
  ///
  /// This function will attempt to grow the table by `delta` table elements. This
  /// can fail if `delta` would exceed the maximum size of the table or if `init`
  /// is the wrong type for this table. If growth is successful then `NULL` is
  /// returned and `prev_size` is filled in with the previous size of the table, in
  /// elements, before the growth happened.
  ///
  /// This function does not take ownership of any of its arguments.
  ffi.Pointer<wasmtime_error_t> wasmtime_table_grow(
    ffi.Pointer<wasmtime_context_t> store,
    ffi.Pointer<wasmtime_table_t> table,
    int delta,
    ffi.Pointer<wasmtime_val_t> init,
    ffi.Pointer<ffi.Uint32> prev_size,
  ) {
    return _wasmtime_table_grow(
      store,
      table,
      delta,
      init,
      prev_size,
    );
  }

  late final _wasmtime_table_growPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
              ffi.Pointer<wasmtime_context_t>,
              ffi.Pointer<wasmtime_table_t>,
              ffi.Uint32,
              ffi.Pointer<wasmtime_val_t>,
              ffi.Pointer<ffi.Uint32>)>>('wasmtime_table_grow');
  late final _wasmtime_table_grow = _wasmtime_table_growPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<wasmtime_context_t>,
          ffi.Pointer<wasmtime_table_t>,
          int,
          ffi.Pointer<wasmtime_val_t>,
          ffi.Pointer<ffi.Uint32>)>();

  /// \brief Creates a new trap.
  ///
  /// \param msg the message to associate with this trap
  /// \param msg_len the byte length of `msg`
  ///
  /// The #wasm_trap_t returned is owned by the caller.
  ffi.Pointer<wasm_trap_t> wasmtime_trap_new(
    ffi.Pointer<ffi.Char> msg,
    int msg_len,
  ) {
    return _wasmtime_trap_new(
      msg,
      msg_len,
    );
  }

  late final _wasmtime_trap_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_trap_t> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('wasmtime_trap_new');
  late final _wasmtime_trap_new = _wasmtime_trap_newPtr.asFunction<
      ffi.Pointer<wasm_trap_t> Function(ffi.Pointer<ffi.Char>, int)>();

  /// \brief Attempts to extract the trap code from this trap.
  ///
  /// Returns `true` if the trap is an instruction trap triggered while
  /// executing Wasm. If `true` is returned then the trap code is returned
  /// through the `code` pointer. If `false` is returned then this is not
  /// an instruction trap -- traps can also be created using wasm_trap_new,
  /// or occur with WASI modules exiting with a certain exit code.
  bool wasmtime_trap_code(
    ffi.Pointer<wasm_trap_t> arg0,
    ffi.Pointer<wasmtime_trap_code_t> code,
  ) {
    return _wasmtime_trap_code(
      arg0,
      code,
    );
  }

  late final _wasmtime_trap_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<wasm_trap_t>,
              ffi.Pointer<wasmtime_trap_code_t>)>>('wasmtime_trap_code');
  late final _wasmtime_trap_code = _wasmtime_trap_codePtr.asFunction<
      bool Function(
          ffi.Pointer<wasm_trap_t>, ffi.Pointer<wasmtime_trap_code_t>)>();

  /// \brief Returns a human-readable name for this frame's function.
  ///
  /// This function will attempt to load a human-readable name for function this
  /// frame points to. This function may return `NULL`.
  ///
  /// The lifetime of the returned name is the same as the #wasm_frame_t itself.
  ffi.Pointer<wasm_name_t> wasmtime_frame_func_name(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasmtime_frame_func_name(
      arg0,
    );
  }

  late final _wasmtime_frame_func_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_name_t> Function(
              ffi.Pointer<wasm_frame_t>)>>('wasmtime_frame_func_name');
  late final _wasmtime_frame_func_name =
      _wasmtime_frame_func_namePtr.asFunction<
          ffi.Pointer<wasm_name_t> Function(ffi.Pointer<wasm_frame_t>)>();

  /// \brief Returns a human-readable name for this frame's module.
  ///
  /// This function will attempt to load a human-readable name for module this
  /// frame points to. This function may return `NULL`.
  ///
  /// The lifetime of the returned name is the same as the #wasm_frame_t itself.
  ffi.Pointer<wasm_name_t> wasmtime_frame_module_name(
    ffi.Pointer<wasm_frame_t> arg0,
  ) {
    return _wasmtime_frame_module_name(
      arg0,
    );
  }

  late final _wasmtime_frame_module_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasm_name_t> Function(
              ffi.Pointer<wasm_frame_t>)>>('wasmtime_frame_module_name');
  late final _wasmtime_frame_module_name =
      _wasmtime_frame_module_namePtr.asFunction<
          ffi.Pointer<wasm_name_t> Function(ffi.Pointer<wasm_frame_t>)>();

  /// \brief Converts from the text format of WebAssembly to to the binary format.
  ///
  /// \param wat this it the input pointer with the WebAssembly Text Format inside of
  /// it. This will be parsed and converted to the binary format.
  /// \param wat_len this it the length of `wat`, in bytes.
  /// \param ret if the conversion is successful, this byte vector is filled in with
  /// the WebAssembly binary format.
  ///
  /// \return a non-null error if parsing fails, or returns `NULL`. If parsing
  /// fails then `ret` isn't touched.
  ///
  /// This function does not take ownership of `wat`, and the caller is expected to
  /// deallocate the returned #wasmtime_error_t and #wasm_byte_vec_t.
  ffi.Pointer<wasmtime_error_t> wasmtime_wat2wasm(
    ffi.Pointer<ffi.Char> wat,
    int wat_len,
    ffi.Pointer<wasm_byte_vec_t> ret,
  ) {
    return _wasmtime_wat2wasm(
      wat,
      wat_len,
      ret,
    );
  }

  late final _wasmtime_wat2wasmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(ffi.Pointer<ffi.Char>,
              ffi.Size, ffi.Pointer<wasm_byte_vec_t>)>>('wasmtime_wat2wasm');
  late final _wasmtime_wat2wasm = _wasmtime_wat2wasmPtr.asFunction<
      ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<wasm_byte_vec_t>)>();
}

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

typedef errno_t = ffi.Int;
typedef rsize_t = __darwin_size_t;
typedef __darwin_size_t = ffi.UnsignedLong;
typedef ssize_t = __darwin_ssize_t;
typedef __darwin_ssize_t = ffi.Long;

final class wasm_byte_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasm_byte_t> data;
}

typedef wasm_byte_t = byte_t;
typedef byte_t = ffi.Char;

final class wasm_config_t extends ffi.Opaque {}

final class wasm_engine_t extends ffi.Opaque {}

final class wasm_store_t extends ffi.Opaque {}

abstract class wasm_mutability_enum {
  static const int WASM_CONST = 0;
  static const int WASM_VAR = 1;
}

final class wasm_limits_t extends ffi.Struct {
  @ffi.Uint32()
  external int min;

  @ffi.Uint32()
  external int max;
}

final class wasm_valtype_t extends ffi.Opaque {}

final class wasm_valtype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_valtype_t>> data;
}

abstract class wasm_valkind_enum {
  static const int WASM_I32 = 0;
  static const int WASM_I64 = 1;
  static const int WASM_F32 = 2;
  static const int WASM_F64 = 3;
  static const int WASM_ANYREF = 128;
  static const int WASM_FUNCREF = 129;
}

typedef wasm_valkind_t = ffi.Uint8;

final class wasm_functype_t extends ffi.Opaque {}

final class wasm_functype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_functype_t>> data;
}

final class wasm_globaltype_t extends ffi.Opaque {}

final class wasm_globaltype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_globaltype_t>> data;
}

/// ////////////////////////////////////////////////////////////////////////////
typedef wasm_mutability_t = ffi.Uint8;

final class wasm_tabletype_t extends ffi.Opaque {}

final class wasm_tabletype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_tabletype_t>> data;
}

final class wasm_memorytype_t extends ffi.Opaque {}

final class wasm_memorytype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_memorytype_t>> data;
}

final class wasm_externtype_t extends ffi.Opaque {}

final class wasm_externtype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_externtype_t>> data;
}

abstract class wasm_externkind_enum {
  static const int WASM_EXTERN_FUNC = 0;
  static const int WASM_EXTERN_GLOBAL = 1;
  static const int WASM_EXTERN_TABLE = 2;
  static const int WASM_EXTERN_MEMORY = 3;
}

typedef wasm_externkind_t = ffi.Uint8;

final class wasm_importtype_t extends ffi.Opaque {}

final class wasm_importtype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_importtype_t>> data;
}

typedef wasm_name_t = wasm_byte_vec_t;

final class wasm_exporttype_t extends ffi.Opaque {}

final class wasm_exporttype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_exporttype_t>> data;
}

/// ////////////////////////////////////////////////////////////////////////////
final class wasm_ref_t extends ffi.Opaque {}

final class wasm_val_t extends ffi.Struct {
  @wasm_valkind_t()
  external int kind;

  external UnnamedUnion1 of;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int32()
  external int i32;

  @ffi.Int64()
  external int i64;

  @float32_t()
  external double f32;

  @float64_t()
  external double f64;

  external ffi.Pointer<wasm_ref_t> ref;
}

typedef float32_t = ffi.Float;
typedef float64_t = ffi.Double;

final class wasm_val_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasm_val_t> data;
}

final class wasm_frame_t extends ffi.Opaque {}

final class wasm_frame_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_frame_t>> data;
}

final class wasm_instance_t extends ffi.Opaque {}

final class wasm_trap_t extends ffi.Opaque {}

typedef wasm_message_t = wasm_name_t;

final class wasm_foreign_t extends ffi.Opaque {}

final class wasm_module_t extends ffi.Opaque {}

final class wasm_shared_module_t extends ffi.Opaque {}

final class wasm_func_t extends ffi.Opaque {}

typedef wasm_func_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<wasm_trap_t> Function(ffi.Pointer<wasm_val_vec_t> args,
            ffi.Pointer<wasm_val_vec_t> results)>>;
typedef wasm_func_callback_with_env_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<wasm_trap_t> Function(
            ffi.Pointer<ffi.Void> env,
            ffi.Pointer<wasm_val_vec_t> args,
            ffi.Pointer<wasm_val_vec_t> results)>>;

final class wasm_global_t extends ffi.Opaque {}

final class wasm_table_t extends ffi.Opaque {}

typedef wasm_table_size_t = ffi.Uint32;

final class wasm_memory_t extends ffi.Opaque {}

typedef wasm_memory_pages_t = ffi.Uint32;

final class wasm_extern_t extends ffi.Opaque {}

final class wasm_extern_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_extern_t>> data;
}

final class wasi_config_t extends ffi.Opaque {}

final class wasmtime_error extends ffi.Opaque {}

/// \typedef wasmtime_error_t
/// \brief Convenience alias for #wasmtime_error
///
/// \struct wasmtime_error
/// \brief Errors generated by Wasmtime.
/// \headerfile wasmtime/error.h
///
/// This opaque type represents an error that happened as part of one of the
/// functions below. Errors primarily have an error message associated with them
/// at this time, which you can acquire by calling #wasmtime_error_message.
///
/// Errors are safe to share across threads and must be deleted with
/// #wasmtime_error_delete.
typedef wasmtime_error_t = wasmtime_error;

/// \brief Different ways that Wasmtime can compile WebAssembly
///
/// The default value is #WASMTIME_STRATEGY_AUTO.
abstract class wasmtime_strategy_enum {
  /// Automatically picks the compilation backend, currently always defaulting
  /// to Cranelift.
  static const int WASMTIME_STRATEGY_AUTO = 0;

  /// Indicates that Wasmtime will unconditionally use Cranelift to compile
  /// WebAssembly code.
  static const int WASMTIME_STRATEGY_CRANELIFT = 1;
}

/// \brief Different ways Wasmtime can optimize generated code.
///
/// The default value is #WASMTIME_OPT_LEVEL_SPEED.
abstract class wasmtime_opt_level_enum {
  /// Generated code will not be optimized at all.
  static const int WASMTIME_OPT_LEVEL_NONE = 0;

  /// Generated code will be optimized purely for speed.
  static const int WASMTIME_OPT_LEVEL_SPEED = 1;

  /// Generated code will be optimized, but some speed optimizations are
  /// disabled if they cause the generated code to be significantly larger.
  static const int WASMTIME_OPT_LEVEL_SPEED_AND_SIZE = 2;
}

/// \brief Different ways to profile JIT code.
///
/// The default is #WASMTIME_PROFILING_STRATEGY_NONE.
abstract class wasmtime_profiling_strategy_enum {
  /// No profiling is enabled at runtime.
  static const int WASMTIME_PROFILING_STRATEGY_NONE = 0;

  /// Linux's "jitdump" support in `perf` is enabled and when Wasmtime is run
  /// under `perf` necessary calls will be made to profile generated JIT code.
  static const int WASMTIME_PROFILING_STRATEGY_JITDUMP = 1;

  /// Support for VTune will be enabled and the VTune runtime will be informed,
  /// at runtime, about JIT code.
  ///
  /// Note that this isn't always enabled at build time.
  static const int WASMTIME_PROFILING_STRATEGY_VTUNE = 2;

  /// Linux's simple "perfmap" support in `perf` is enabled and when Wasmtime is
  /// run under `perf` necessary calls will be made to profile generated JIT
  /// code.
  static const int WASMTIME_PROFILING_STRATEGY_PERFMAP = 3;
}

/// \brief Specifier for how Wasmtime will compile code, values are in
/// #wasmtime_strategy_enum
typedef wasmtime_strategy_t = ffi.Uint8;

/// \brief Specifier of what optimization level to use for generated JIT code.
///
/// See #wasmtime_opt_level_enum for possible values.
typedef wasmtime_opt_level_t = ffi.Uint8;

/// \brief Different ways wasmtime can enable profiling JIT code.
///
/// See #wasmtime_profiling_strategy_enum for possible values.
typedef wasmtime_profiling_strategy_t = ffi.Uint8;

final class wasmtime_module extends ffi.Opaque {}

/// \typedef wasmtime_module_t
/// \brief Convenience alias for #wasmtime_module
///
/// \struct wasmtime_module
/// \brief A compiled Wasmtime module.
///
/// This type represents a compiled WebAssembly module. The compiled module is
/// ready to be instantiated and can be inspected for imports/exports. It is safe
/// to use a module across multiple threads simultaneously.
typedef wasmtime_module_t = wasmtime_module;

final class wasmtime_store extends ffi.Opaque {}

final class wasmtime_context extends ffi.Opaque {}

/// \typedef wasmtime_store_t
/// \brief Convenience alias for #wasmtime_store_t
///
/// \struct wasmtime_store
/// \brief Storage of WebAssembly objects
///
/// A store is the unit of isolation between WebAssembly instances in an
/// embedding of Wasmtime. Values in one #wasmtime_store_t cannot flow into
/// another #wasmtime_store_t. Stores are cheap to create and cheap to dispose.
/// It's expected that one-off stores are common in embeddings.
///
/// Objects stored within a #wasmtime_store_t are referenced with integer handles
/// rather than interior pointers. This means that most APIs require that the
/// store be explicitly passed in, which is done via #wasmtime_context_t. It is
/// safe to move a #wasmtime_store_t to any thread at any time. A store generally
/// cannot be concurrently used, however.
typedef wasmtime_store_t = wasmtime_store;

/// \typedef wasmtime_context_t
/// \brief Convenience alias for #wasmtime_context
///
/// \struct wasmtime_context
/// \brief An interior pointer into a #wasmtime_store_t which is used as
/// "context" for many functions.
///
/// This context pointer is used pervasively throught Wasmtime's API. This can be
/// acquired from #wasmtime_store_context or #wasmtime_caller_context. The
/// context pointer for a store is the same for the entire lifetime of a store,
/// so it can safely be stored adjacent to a #wasmtime_store_t itself.
///
/// Usage of a #wasmtime_context_t must not outlive the original
/// #wasmtime_store_t. Additionally #wasmtime_context_t can only be used in
/// situations where it has explicitly been granted access to doing so. For
/// example finalizers cannot use #wasmtime_context_t because they are not given
/// access to it.
typedef wasmtime_context_t = wasmtime_context;

/// \brief Representation of a function in Wasmtime.
///
/// Functions are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Functions cannot
/// interoperate between #wasmtime_store_t instances and if the wrong function
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_func extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Internal index within the store.
  @ffi.Size()
  external int index;
}

/// \brief Representation of a table in Wasmtime.
///
/// Tables are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Tables cannot
/// interoperate between #wasmtime_store_t instances and if the wrong table
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_table extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Internal index within the store.
  @ffi.Size()
  external int index;
}

/// \brief Representation of a memory in Wasmtime.
///
/// Memories are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Memories cannot
/// interoperate between #wasmtime_store_t instances and if the wrong memory
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_memory extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Internal index within the store.
  @ffi.Size()
  external int index;
}

/// \brief Representation of a global in Wasmtime.
///
/// Globals are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Globals cannot
/// interoperate between #wasmtime_store_t instances and if the wrong global
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_global extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Internal index within the store.
  @ffi.Size()
  external int index;
}

/// \typedef wasmtime_extern_union_t
/// \brief Convenience alias for #wasmtime_extern_union
///
/// \union wasmtime_extern_union
/// \brief Container for different kinds of extern items.
///
/// This type is contained in #wasmtime_extern_t and contains the payload for the
/// various kinds of items an extern wasm item can be.
final class wasmtime_extern_union extends ffi.Union {
  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_FUNC
  external wasmtime_func_t func;

  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_GLOBAL
  external wasmtime_global_t global;

  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_TABLE
  external wasmtime_table_t table;

  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_MEMORY
  external wasmtime_memory_t memory;
}

/// \brief Representation of a function in Wasmtime.
///
/// Functions are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Functions cannot
/// interoperate between #wasmtime_store_t instances and if the wrong function
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
typedef wasmtime_func_t = wasmtime_func;

/// \brief Representation of a global in Wasmtime.
///
/// Globals are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Globals cannot
/// interoperate between #wasmtime_store_t instances and if the wrong global
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
typedef wasmtime_global_t = wasmtime_global;

/// \brief Representation of a table in Wasmtime.
///
/// Tables are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Tables cannot
/// interoperate between #wasmtime_store_t instances and if the wrong table
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
typedef wasmtime_table_t = wasmtime_table;

/// \brief Representation of a memory in Wasmtime.
///
/// Memories are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Memories cannot
/// interoperate between #wasmtime_store_t instances and if the wrong memory
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
typedef wasmtime_memory_t = wasmtime_memory;

/// \typedef wasmtime_extern_t
/// \brief Convenience alias for #wasmtime_extern_t
///
/// \union wasmtime_extern
/// \brief Container for different kinds of extern items.
///
/// Note that this structure may contain an owned value, namely
/// #wasmtime_module_t, depending on the context in which this is used. APIs
/// which consume a #wasmtime_extern_t do not take ownership, but APIs that
/// return #wasmtime_extern_t require that #wasmtime_extern_delete is called to
/// deallocate the value.
final class wasmtime_extern extends ffi.Struct {
  /// Discriminant of which field of #of is valid.
  @wasmtime_extern_kind_t()
  external int kind;

  /// Container for the extern item's value.
  external wasmtime_extern_union_t of;
}

/// \brief Discriminant of #wasmtime_extern_t
typedef wasmtime_extern_kind_t = ffi.Uint8;

/// \typedef wasmtime_extern_union_t
/// \brief Convenience alias for #wasmtime_extern_union
///
/// \union wasmtime_extern_union
/// \brief Container for different kinds of extern items.
///
/// This type is contained in #wasmtime_extern_t and contains the payload for the
/// various kinds of items an extern wasm item can be.
typedef wasmtime_extern_union_t = wasmtime_extern_union;

/// \typedef wasmtime_extern_t
/// \brief Convenience alias for #wasmtime_extern_t
///
/// \union wasmtime_extern
/// \brief Container for different kinds of extern items.
///
/// Note that this structure may contain an owned value, namely
/// #wasmtime_module_t, depending on the context in which this is used. APIs
/// which consume a #wasmtime_extern_t do not take ownership, but APIs that
/// return #wasmtime_extern_t require that #wasmtime_extern_delete is called to
/// deallocate the value.
typedef wasmtime_extern_t = wasmtime_extern;

final class wasmtime_externref extends ffi.Opaque {}

/// \typedef wasmtime_externref_t
/// \brief Convenience alias for #wasmtime_externref
///
/// \struct wasmtime_externref
/// \brief A host-defined un-forgeable reference to pass into WebAssembly.
///
/// This structure represents an `externref` that can be passed to WebAssembly.
/// It cannot be forged by WebAssembly itself and is guaranteed to have been
/// created by the host.
typedef wasmtime_externref_t = wasmtime_externref;

/// \typedef wasmtime_valunion_t
/// \brief Convenience alias for #wasmtime_valunion
///
/// \union wasmtime_valunion
/// \brief Container for different kinds of wasm values.
///
/// This type is contained in #wasmtime_val_t and contains the payload for the
/// various kinds of items a value can be.
final class wasmtime_valunion extends ffi.Union {
  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I32
  @ffi.Int32()
  external int i32;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I64
  @ffi.Int64()
  external int i64;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F32
  @float32_t()
  external double f32;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F64
  @float64_t()
  external double f64;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_FUNCREF
  ///
  /// If this value represents a `ref.null func` value then the `store_id` field
  /// is set to zero.
  external wasmtime_func_t funcref;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_EXTERNREF
  ///
  /// If this value represents a `ref.null extern` value then this pointer will
  /// be `NULL`.
  external ffi.Pointer<wasmtime_externref_t> externref;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_V128
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> v128;
}

/// \typedef wasmtime_val_raw_t
/// \brief Convenience alias for #wasmtime_val_raw
///
/// \union wasmtime_val_raw
/// \brief Container for possible wasm values.
///
/// This type is used on conjunction with #wasmtime_func_new_unchecked as well
/// as #wasmtime_func_call_unchecked. Instances of this type do not have type
/// information associated with them, it's up to the embedder to figure out
/// how to interpret the bits contained within, often using some other channel
/// to determine the type.
final class wasmtime_val_raw extends ffi.Union {
  /// Field for when this val is a WebAssembly `i32` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Int32()
  external int i32;

  /// Field for when this val is a WebAssembly `i64` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Int64()
  external int i64;

  /// Field for when this val is a WebAssembly `f32` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @float32_t()
  external double f32;

  /// Field for when this val is a WebAssembly `f64` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @float64_t()
  external double f64;

  /// Field for when this val is a WebAssembly `v128` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> v128;

  /// Field for when this val is a WebAssembly `funcref` value.
  ///
  /// If this is set to 0 then it's a null funcref, otherwise this must be
  /// passed to `wasmtime_func_from_raw` to determine the `wasmtime_func_t`.
  ///
  /// Note that this field is always stored in a little-endian format.
  external ffi.Pointer<ffi.Void> funcref;

  /// Field for when this val is a WebAssembly `externref` value.
  ///
  /// If this is set to 0 then it's a null externref, otherwise this must be
  /// passed to `wasmtime_externref_from_raw` to determine the
  /// `wasmtime_externref_t`.
  ///
  /// Note that this field is always stored in a little-endian format.
  external ffi.Pointer<ffi.Void> externref;
}

/// \typedef wasmtime_val_t
/// \brief Convenience alias for #wasmtime_val_t
///
/// \union wasmtime_val
/// \brief Container for different kinds of wasm values.
///
/// Note that this structure may contain an owned value, namely
/// #wasmtime_externref_t, depending on the context in which this is used. APIs
/// which consume a #wasmtime_val_t do not take ownership, but APIs that return
/// #wasmtime_val_t require that #wasmtime_val_delete is called to deallocate
/// the value.
final class wasmtime_val extends ffi.Struct {
  /// Discriminant of which field of #of is valid.
  @wasmtime_valkind_t()
  external int kind;

  /// Container for the extern item's value.
  external wasmtime_valunion_t of;
}

/// \brief Discriminant stored in #wasmtime_val::kind
typedef wasmtime_valkind_t = ffi.Uint8;

/// \typedef wasmtime_valunion_t
/// \brief Convenience alias for #wasmtime_valunion
///
/// \union wasmtime_valunion
/// \brief Container for different kinds of wasm values.
///
/// This type is contained in #wasmtime_val_t and contains the payload for the
/// various kinds of items a value can be.
typedef wasmtime_valunion_t = wasmtime_valunion;

/// \typedef wasmtime_val_t
/// \brief Convenience alias for #wasmtime_val_t
///
/// \union wasmtime_val
/// \brief Container for different kinds of wasm values.
///
/// Note that this structure may contain an owned value, namely
/// #wasmtime_externref_t, depending on the context in which this is used. APIs
/// which consume a #wasmtime_val_t do not take ownership, but APIs that return
/// #wasmtime_val_t require that #wasmtime_val_delete is called to deallocate
/// the value.
typedef wasmtime_val_t = wasmtime_val;

final class wasmtime_caller extends ffi.Opaque {}

/// \brief Callback signature for #wasmtime_func_new.
///
/// This is the function signature for host functions that can be made accessible
/// to WebAssembly. The arguments to this function are:
///
/// \param env user-provided argument passed to #wasmtime_func_new
/// \param caller a temporary object that can only be used during this function
/// call. Used to acquire #wasmtime_context_t or caller's state
/// \param args the arguments provided to this function invocation
/// \param nargs how many arguments are provided
/// \param results where to write the results of this function
/// \param nresults how many results must be produced
///
/// Callbacks are guaranteed to get called with the right types of arguments, but
/// they must produce the correct number and types of results. Failure to do so
/// will cause traps to get raised on the wasm side.
///
/// This callback can optionally return a #wasm_trap_t indicating that a trap
/// should be raised in WebAssembly. It's expected that in this case the caller
/// relinquishes ownership of the trap and it is passed back to the engine.
typedef wasmtime_func_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<wasm_trap_t> Function(
            ffi.Pointer<ffi.Void> env,
            ffi.Pointer<wasmtime_caller_t> caller,
            ffi.Pointer<wasmtime_val_t> args,
            ffi.Size nargs,
            ffi.Pointer<wasmtime_val_t> results,
            ffi.Size nresults)>>;

/// \typedef wasmtime_caller_t
/// \brief Alias to #wasmtime_caller
///
/// \brief Structure used to learn about the caller of a host-defined function.
/// \struct wasmtime_caller
///
/// This structure is an argument to #wasmtime_func_callback_t. The purpose
/// of this structure is acquire a #wasmtime_context_t pointer to interact with
/// objects, but it can also be used for inspect the state of the caller (such as
/// getting memories and functions) with #wasmtime_caller_export_get.
///
/// This object is never owned and does not need to be deleted.
typedef wasmtime_caller_t = wasmtime_caller;

/// \brief Callback signature for #wasmtime_func_new_unchecked.
///
/// This is the function signature for host functions that can be made accessible
/// to WebAssembly. The arguments to this function are:
///
/// \param env user-provided argument passed to #wasmtime_func_new_unchecked
/// \param caller a temporary object that can only be used during this function
/// call. Used to acquire #wasmtime_context_t or caller's state
/// \param args_and_results storage space for both the parameters to the
/// function as well as the results of the function. The size of this
/// array depends on the function type that the host function is created
/// with, but it will be the maximum of the number of parameters and
/// number of results.
/// \param num_args_and_results the size of the `args_and_results` parameter in
/// units of #wasmtime_val_raw_t.
///
/// This callback can optionally return a #wasm_trap_t indicating that a trap
/// should be raised in WebAssembly. It's expected that in this case the caller
/// relinquishes ownership of the trap and it is passed back to the engine.
///
/// This differs from #wasmtime_func_callback_t in that the payload of
/// `args_and_results` does not have type information, nor does it have sizing
/// information. This is especially unsafe because it's only valid within the
/// particular #wasm_functype_t that the function was created with. The onus is
/// on the embedder to ensure that `args_and_results` are all read correctly
/// for parameters and all written for results within the execution of a
/// function.
///
/// Parameters will be listed starting at index 0 in the `args_and_results`
/// array. Results are also written starting at index 0, which will overwrite
/// the arguments.
typedef wasmtime_func_unchecked_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<wasm_trap_t> Function(
            ffi.Pointer<ffi.Void> env,
            ffi.Pointer<wasmtime_caller_t> caller,
            ffi.Pointer<wasmtime_val_raw_t> args_and_results,
            ffi.Size num_args_and_results)>>;

/// \typedef wasmtime_val_raw_t
/// \brief Convenience alias for #wasmtime_val_raw
///
/// \union wasmtime_val_raw
/// \brief Container for possible wasm values.
///
/// This type is used on conjunction with #wasmtime_func_new_unchecked as well
/// as #wasmtime_func_call_unchecked. Instances of this type do not have type
/// information associated with them, it's up to the embedder to figure out
/// how to interpret the bits contained within, often using some other channel
/// to determine the type.
typedef wasmtime_val_raw_t = wasmtime_val_raw;

/// \brief Representation of a instance in Wasmtime.
///
/// Instances are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Instances cannot
/// interoperate between #wasmtime_store_t instances and if the wrong instance
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_instance extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Internal index within the store.
  @ffi.Size()
  external int index;
}

/// \brief Representation of a instance in Wasmtime.
///
/// Instances are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Instances cannot
/// interoperate between #wasmtime_store_t instances and if the wrong instance
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
typedef wasmtime_instance_t = wasmtime_instance;

final class wasmtime_linker extends ffi.Opaque {}

/// \typedef wasmtime_linker_t
/// \brief Alias to #wasmtime_linker
///
/// \struct #wasmtime_linker
/// \brief Object used to conveniently link together and instantiate wasm
/// modules.
///
/// This type corresponds to the `wasmtime::Linker` type in Rust. This
/// type is intended to make it easier to manage a set of modules that link
/// together, or to make it easier to link WebAssembly modules to WASI.
///
/// A #wasmtime_linker_t is a higher level way to instantiate a module than
/// #wasm_instance_new since it works at the "string" level of imports rather
/// than requiring 1:1 mappings.
typedef wasmtime_linker_t = wasmtime_linker;

/// \brief Trap codes for instruction traps.
abstract class wasmtime_trap_code_enum {
  /// The current stack space was exhausted.
  static const int WASMTIME_TRAP_CODE_STACK_OVERFLOW = 0;

  /// An out-of-bounds memory access.
  static const int WASMTIME_TRAP_CODE_MEMORY_OUT_OF_BOUNDS = 1;

  /// A wasm atomic operation was presented with a not-naturally-aligned linear-memory address.
  static const int WASMTIME_TRAP_CODE_HEAP_MISALIGNED = 2;

  /// An out-of-bounds access to a table.
  static const int WASMTIME_TRAP_CODE_TABLE_OUT_OF_BOUNDS = 3;

  /// Indirect call to a null table entry.
  static const int WASMTIME_TRAP_CODE_INDIRECT_CALL_TO_NULL = 4;

  /// Signature mismatch on indirect call.
  static const int WASMTIME_TRAP_CODE_BAD_SIGNATURE = 5;

  /// An integer arithmetic operation caused an overflow.
  static const int WASMTIME_TRAP_CODE_INTEGER_OVERFLOW = 6;

  /// An integer division by zero.
  static const int WASMTIME_TRAP_CODE_INTEGER_DIVISION_BY_ZERO = 7;

  /// Failed float-to-int conversion.
  static const int WASMTIME_TRAP_CODE_BAD_CONVERSION_TO_INTEGER = 8;

  /// Code that was supposed to have been unreachable was reached.
  static const int WASMTIME_TRAP_CODE_UNREACHABLE_CODE_REACHED = 9;

  /// Execution has potentially run too long and may be interrupted.
  static const int WASMTIME_TRAP_CODE_INTERRUPT = 10;

  /// Execution has run out of the configured fuel amount.
  static const int WASMTIME_TRAP_CODE_OUT_OF_FUEL = 11;
}

/// \brief Code of an instruction trap.
///
/// See #wasmtime_trap_code_enum for possible values.
typedef wasmtime_trap_code_t = ffi.Uint8;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_XROS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_14_0 = 140000;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_17_0 = 170000;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_10_0 = 100000;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_17_0 = 170000;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_8_0 = 80000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_23_0 = 230000;

const int __XROS_1_0 = 10000;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_14_0 = 140000;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 140000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 140000;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const String __ASSERT_FILE_NAME = 'temp_for_macros.hpp';

const int WASMTIME_EXTERN_FUNC = 0;

const int WASMTIME_EXTERN_GLOBAL = 1;

const int WASMTIME_EXTERN_TABLE = 2;

const int WASMTIME_EXTERN_MEMORY = 3;

const int WASMTIME_I32 = 0;

const int WASMTIME_I64 = 1;

const int WASMTIME_F32 = 2;

const int WASMTIME_F64 = 3;

const int WASMTIME_V128 = 4;

const int WASMTIME_FUNCREF = 5;

const int WASMTIME_EXTERNREF = 6;

const String WASMTIME_VERSION = '13.0.0';

const int WASMTIME_VERSION_MAJOR = 13;

const int WASMTIME_VERSION_MINOR = 0;

const int WASMTIME_VERSION_PATCH = 0;
